/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

import type { CSSProperties } from './StyleXCSSTypes';

// Using an opaque type to declare ClassNames generated by stylex.
declare const StyleXClassNameTag: unique symbol;
export type StyleXClassNameFor<K, V> = string & {
  _opaque: typeof StyleXClassNameTag;
  _key: K;
  _value: V;
};

export type StyleXClassNameForValue<V> = StyleXClassNameFor<unknown, V>;
export type StyleXClassNameForKey<K> = StyleXClassNameFor<K, unknown>;
export type StyleXClassName = StyleXClassNameFor<unknown, unknown>;
// Type for arbitrarily nested Array.
export type StyleXArray<T> = T | ReadonlyArray<StyleXArray<T>>;

declare const StyleXVarTag: unique symbol;
export type StyleXVar<_Val> = string & typeof StyleXVarTag;

// prettier-ignore
type NonDollarChars =
  | 'a' | 'A' | 'b' | 'B' | 'c' | 'C' | 'd' | 'D'
  | 'e' | 'E' | 'f' | 'F' | 'g' | 'G'
  | 'h' | 'H' | 'i' | 'I' | 'j' | 'J' | 'k' | 'K'
  | 'l' | 'L' | 'm' | 'M' | 'n' | 'N' | 'o' | 'O' | 'p' | 'P'
  | 'q' | 'Q' | 'r' | 'R' | 's' | 'S' | 't' | 'T'
  | 'u' | 'U' | 'v' | 'V' | 'w' | 'W'
  | 'x' | 'X' | 'y' | 'Y' | 'z' | 'Z'
  | '-' | '_' | '@' | ':';

// Strings that don't start with a dollar sign.
// So that we can `&` with {$$css: true} without type errors.
type NonDollarStr = `${NonDollarChars}${string}`;
type PseudoClassStr = `:${string}`;
type AtRuleStr = `@${string}`;

type CondStr = PseudoClassStr | AtRuleStr;

type CSSPropertiesWithExtras = Partial<
  Readonly<
    CSSProperties & {
      '::after': CSSProperties;
      '::backdrop': CSSProperties;
      '::before': CSSProperties;
      '::cue': CSSProperties;
      '::cue-region': CSSProperties;
      '::first-letter': CSSProperties;
      '::first-line': CSSProperties;
      '::file-selector-button': CSSProperties;
      '::grammar-error': CSSProperties;
      '::marker': CSSProperties;
      // This is a pattern and not a static key so it cannot be typed correctly.
      // '::part()': CSSProperties;
      '::placeholder': CSSProperties;
      '::selection': CSSProperties;
      // This is a pattern and not a static key so it cannot be typed correctly.
      // '::slotted()': CSSProperties;
      '::spelling-error': CSSProperties;
      '::target-text': CSSProperties;
    }
  >
>;

export type NestedCSSPropTypes = Partial<
  Readonly<{
    [Key in keyof CSSPropertiesWithExtras]: StyleXClassNameFor<
      Key,
      CSSPropertiesWithExtras[Key]
    >;
  }>
>;

type UserAuthoredStyles = { [key: NonDollarStr]: unknown };
export type StyleXSingleStyle = false | (null | undefined | NestedCSSPropTypes);
export type XStyle<T extends UserAuthoredStyles = NestedCSSPropTypes> =
  StyleXArray<false | (null | undefined | Readonly<T & { $$css: true }>)>;
export type XStyleWithout<T extends UserAuthoredStyles> = XStyle<
  Readonly<Pick<NestedCSSPropTypes, Exclude<keyof NestedCSSPropTypes, keyof T>>>
>;

export type Keyframes = Readonly<{ [name: NonDollarStr]: CSSProperties }>;
export type LegacyTheme = Readonly<{ [constantName: NonDollarStr]: string }>;

type ComplexStyleValueType<T> = T extends string | number | null
  ? T
  : T extends StyleXVar<infer U>
  ? U
  : T extends ReadonlyArray<infer U>
  ? U
  : T extends Readonly<{ default: infer A; [cond: CondStr]: infer B }>
  ? ComplexStyleValueType<A> | ComplexStyleValueType<B>
  : T;

type _MapNamespace<CSS> = Readonly<{
  [Key in keyof CSS]: StyleXClassNameFor<Key, ComplexStyleValueType<CSS[Key]>>;
}>;

export type MapNamespace<CSS> = Readonly<
  _MapNamespace<CSS> & Readonly<{ $$css: true }>
>;

export type MapNamespaces<
  S extends {
    [key: string]: UserAuthoredStyles | ((...args: any) => UserAuthoredStyles);
  },
> = Readonly<{
  [Key in keyof S]: S[Key] extends (...args: infer Args) => infer Obj
    ? (...args: Args) => Readonly<[MapNamespace<Obj>, InlineStyles]>
    : MapNamespace<S[Key]>;
}>;

export type Stylex$Create = <
  const S extends {
    [key: string]: UserAuthoredStyles | ((...args: any) => UserAuthoredStyles);
  },
>(
  styles: S,
) => MapNamespaces<S>;

export type CompiledStyles = Readonly<
  {
    [key: NonDollarStr]:
      | StyleXClassName
      | Readonly<{ [key: NonDollarStr]: StyleXClassName }>;
  } & { $$css: true }
>;

export type InlineStyles = Readonly<
  { [key: NonDollarStr]: string } & { $$css?: void }
>;

type _GenStylePropType<CSS extends UserAuthoredStyles> = Readonly<{
  [Key in keyof CSS]: StyleXClassNameFor<Key, Readonly<CSS[Key]>>;
}>;
type GenStylePropType<CSS extends UserAuthoredStyles> = Readonly<
  _GenStylePropType<CSS> & { $$css: true } & Partial<{
      [Key in Exclude<
        keyof CSSPropertiesWithExtras,
        keyof CSS | '$$css'
      >]: never;
    }>
>;

// Replace `XStyle` with this.
export type StaticStyles<
  CSS extends UserAuthoredStyles = CSSPropertiesWithExtras,
> = StyleXArray<false | null | void | GenStylePropType<CSS>>;
export type StaticStylesWithout<CSS extends UserAuthoredStyles> = StaticStyles<
  Omit<CSSPropertiesWithExtras, keyof CSS>
>;

export type StyleXStyles<
  CSS extends UserAuthoredStyles = CSSPropertiesWithExtras,
> = StyleXArray<
  | null
  | void
  | false
  | GenStylePropType<CSS>
  | Readonly<[GenStylePropType<CSS>, InlineStyles]>
>;
export type StyleXStylesWithout<CSS extends UserAuthoredStyles> = StyleXStyles<
  Omit<CSSPropertiesWithExtras, keyof CSS>
>;

declare const StyleXThemeTag: unique symbol;
export type Theme<
  Tokens extends { [key: NonDollarStr]: unknown },
  ID extends symbol = symbol,
> = Readonly<{ [_Key in keyof Tokens]: string }> & {
  $opaqueId: ID;
  $tokens: Tokens;
} & typeof StyleXThemeTag;

export type TokensFromTheme<T extends Theme<TTokens>> = T['$tokens'];

export type IDFromTheme<T extends Theme<TTokens>> = T['$opaqueId'];

type TTokens = {
  [key: NonDollarStr]: string | { default: string; [key: AtRuleStr]: string };
};

export type FlattenTokens<T extends TTokens> = Readonly<{
  [Key in keyof T]: T[Key] extends { [key: string]: infer X } ? X : T[Key];
}>;

export type StyleX$CreateVars = <
  DefaultTokens extends TTokens,
  ID extends symbol = symbol,
>(
  tokens: DefaultTokens,
) => Theme<FlattenTokens<DefaultTokens>, ID>;

export type Variant<
  T extends Theme<TTokens, symbol>,
  // eslint-disable-next-line no-unused-vars
  Tag extends symbol = symbol,
> = Tag &
  Readonly<{
    theme: StyleXClassNameFor<string, IDFromTheme<T>>;
  }>;

type OverridesForTokenType<Config extends { [key: string]: any }> = {
  [Key in keyof Config]:
    | Config[Key]
    | { default: Config[Key]; [atRule: AtRuleStr]: Config[Key] };
};

export type StyleX$OverrideVars = <
  BaseTokens extends Theme<any>,
  ID extends symbol = symbol,
>(
  baseTokens: BaseTokens,
  overrides: OverridesForTokenType<TokensFromTheme<BaseTokens>>,
) => Variant<BaseTokens, ID>;
