'use strict';

var t = require('@babel/types');
var path = require('path');
var require$$0 = require('postcss-value-parser');
var core = require('@babel/core');
var traverse = require('@babel/traverse');
var fs = require('fs');
var require$$0$1 = require('invariant');
var require$$1 = require('styleq');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var t__namespace = /*#__PURE__*/_interopNamespaceDefault(t);

var name = "@stylexjs/stylex";

class StateManager {
  stylexImport = new Set();
  stylexCreateImport = new Set();
  stylexIncludeImport = new Set();
  stylexFirstThatWorksImport = new Set();
  stylexKeyframesImport = new Set();
  stylexCreateVarsImport = new Set();
  stylexOverrideVarsImport = new Set();
  stylexTypesImport = new Set();
  styleMap = new Map();
  styleVars = new Map();
  styleVarsToKeep = new Set();
  inStyleXCreate = false;
  constructor(state) {
    this._state = state;
    state.file.metadata.stylex = [];
  }
  get options() {
    const options = this._state.opts || {};
    const opts = {
      ...options,
      dev: !!options.dev,
      test: !!options.test,
      stylexSheetName: options.stylexSheetName ?? undefined,
      classNamePrefix: options.classNamePrefix ?? "x",
      importSources: options.importSources ?? [name, "stylex"],
      definedStylexCSSVariables: options.definedStylexCSSVariables ?? {},
      genConditionalClasses: !!options.genConditionalClasses,
      styleResolution: options.styleResolution ?? "application-order",
      unstable_moduleResolution: options.unstable_moduleResolution ?? undefined
    };
    this._state.opts = opts;
    return this._state.opts;
  }
  get canReferenceTheme() {
    return !!this.inStyleXCreate;
  }
  get metadata() {
    return this._state.file.metadata;
  }
  get stylexSheetName() {
    return this.options.stylexSheetName ?? undefined;
  }
  get isDev() {
    return !!this.options.dev;
  }
  get isTest() {
    return !!this.options.test;
  }
  get filename() {
    return this._state.filename;
  }
  get cssVars() {
    return this.options.definedStylexCSSVariables;
  }
  get fileNameForHashing() {
    const filename = this.filename;
    const themeFileExtension = this.options.unstable_moduleResolution?.themeFileExtension ?? ".stylex";
    if (filename == null || !matchesFileSuffix(themeFileExtension)(filename) || this.options.unstable_moduleResolution == null) {
      return null;
    }
    switch (this.options.unstable_moduleResolution.type) {
      case "haste":
        return path.basename(filename);
      default:
        {
          const rootDir = this.options.unstable_moduleResolution.rootDir;
          return path.relative(rootDir, filename);
        }
    }
  }
  importPathResolver(importPath) {
    const sourceFilePath = this.filename;
    if (sourceFilePath == null) {
      return false;
    }
    switch (this.options.unstable_moduleResolution?.type) {
      case "commonJS":
        {
          const rootDir = this.options.unstable_moduleResolution.rootDir;
          const themeFileExtension = this.options.unstable_moduleResolution.themeFileExtension ?? ".stylex";
          if (!matchesFileSuffix(themeFileExtension)(importPath)) {
            return false;
          }
          const resolvedFilePath = filePathResolver(importPath, sourceFilePath);
          return resolvedFilePath ? ["themeNameRef", path.relative(rootDir, resolvedFilePath)] : false;
        }
      case "haste":
        {
          const themeFileExtension = this.options.unstable_moduleResolution.themeFileExtension ?? ".stylex";
          if (!matchesFileSuffix(themeFileExtension)(importPath)) {
            return false;
          }
          return ["themeNameRef", addFileExtension(importPath, sourceFilePath)];
        }
      case "experimental_crossFileParsing":
        {
          const themeFileExtension = this.options.unstable_moduleResolution.themeFileExtension ?? ".stylex";
          if (!matchesFileSuffix(themeFileExtension)(importPath)) {
            return false;
          }
          const resolvedFilePath = filePathResolver(importPath, sourceFilePath);
          return resolvedFilePath ? ["filePath", resolvedFilePath] : false;
        }
      default:
        return false;
    }
  }
  addStyle(style) {
    this.metadata.stylex.push(style);
  }
  markComposedNamespace(memberExpression) {
    this.styleVarsToKeep.add(memberExpression);
  }
}
const filePathResolver = (relativeFilePath, sourceFilePath) => {
  const fileToLookFor = relativeFilePath;
  if (EXTENSIONS.some(ext => fileToLookFor.endsWith(ext))) {
    try {
      const resolvedFilePath = require.resolve(fileToLookFor, {
        paths: [path.dirname(sourceFilePath)]
      });
      return resolvedFilePath;
    } catch {}
  }
  for (const ext of EXTENSIONS) {
    try {
      const resolvedFilePath = require.resolve(fileToLookFor + ext, {
        paths: [path.dirname(sourceFilePath)]
      });
      return resolvedFilePath;
    } catch {}
  }
};
const EXTENSIONS = [".js", ".ts", ".tsx", ".jsx", ".mjs", ".cjs"];
const addFileExtension = (importedFilePath, sourceFile) => {
  if (EXTENSIONS.some(ext => importedFilePath.endsWith(ext))) {
    return importedFilePath;
  }
  const fileExtension = path.extname(sourceFile);
  return importedFilePath + fileExtension;
};
const matchesFileSuffix = allowedSuffix => filename => filename.endsWith(`${allowedSuffix}.js`) || filename.endsWith(`${allowedSuffix}.ts`) || filename.endsWith(`${allowedSuffix}.tsx`) || filename.endsWith(`${allowedSuffix}.jsx`) || filename.endsWith(`${allowedSuffix}.mjs`) || filename.endsWith(`${allowedSuffix}.cjs`) || filename.endsWith(allowedSuffix);

function readImportDeclarations(path, state) {
  const {
    node
  } = path;
  if (node?.importKind === "type" || node?.importKind === "typeof") {
    return;
  }
  if (state.options.importSources.includes(node.source.value)) {
    for (const specifier of node.specifiers) {
      if (specifier.type === "ImportDefaultSpecifier") {
        state.stylexImport.add(specifier.local.name);
      }
      if (specifier.type === "ImportNamespaceSpecifier") {
        state.stylexImport.add(specifier.local.name);
      }
      if (specifier.type === "ImportSpecifier") {
        if (specifier.imported.type === "Identifier") {
          if (specifier.imported.name === "create") {
            state.stylexCreateImport.add(specifier.local.name);
          }
          if (specifier.imported.name === "keyframes") {
            state.stylexKeyframesImport.add(specifier.local.name);
          }
          if (specifier.imported.name === "include") {
            state.stylexIncludeImport.add(specifier.local.name);
          }
          if (specifier.imported.name === "firstThatWorks") {
            state.stylexFirstThatWorksImport.add(specifier.local.name);
          }
          if (specifier.imported.name === "unstable_createVars") {
            state.stylexCreateVarsImport.add(specifier.local.name);
          }
          if (specifier.imported.name === "unstable_overrideVars") {
            state.stylexCreateVarsImport.add(specifier.local.name);
          }
          if (specifier.imported.name === "types") {
            state.stylexTypesImport.add(specifier.local.name);
          }
        }
        if (specifier.imported.type === "StringLiteral") {
          if (specifier.imported.value === "create") {
            state.stylexCreateImport.add(specifier.local.name);
          }
          if (specifier.imported.value === "keyframes") {
            state.stylexKeyframesImport.add(specifier.local.name);
          }
          if (specifier.imported.value === "include") {
            state.stylexIncludeImport.add(specifier.local.name);
          }
          if (specifier.imported.value === "firstThatWorks") {
            state.stylexFirstThatWorksImport.add(specifier.local.name);
          }
          if (specifier.imported.value === "unstable_createVars") {
            state.stylexCreateVarsImport.add(specifier.local.name);
          }
          if (specifier.imported.value === "unstable_overrideVars  ") {
            state.stylexCreateVarsImport.add(specifier.local.name);
          }
          if (specifier.imported.value === "types  ") {
            state.stylexTypesImport.add(specifier.local.name);
          }
        }
      }
    }
  }
}
function readRequires(path, state) {
  const {
    node
  } = path;
  if (node.init?.type === "CallExpression" && node.init?.callee?.type === "Identifier" && node.init?.callee?.name === "require" && node.init?.arguments?.length === 1 && node.init?.arguments?.[0].type === "StringLiteral" && (node.init?.arguments?.[0].value === "stylex" || state.options.importSources.includes(node.init?.arguments?.[0].value))) {
    if (node.id.type === "Identifier") {
      state.stylexImport.add(node.id.name);
    }
    if (node.id.type === "ObjectPattern") {
      for (const prop of node.id.properties) {
        if (prop.type === "ObjectProperty" && prop.key.type === "Identifier" && prop.value.type === "Identifier") {
          const value = prop.value;
          if (prop.key.name === "create") {
            state.stylexCreateImport.add(value.name);
          }
          if (prop.key.name === "keyframes") {
            state.stylexKeyframesImport.add(value.name);
          }
          if (prop.key.name === "include") {
            state.stylexIncludeImport.add(value.name);
          }
          if (prop.key.name === "firstThatWorks") {
            state.stylexFirstThatWorksImport.add(value.name);
          }
          if (prop.key.name === "unstable_createVars") {
            state.stylexCreateVarsImport.add(value.name);
          }
          if (prop.key.name === "unstable_overrideVars") {
            state.stylexCreateVarsImport.add(value.name);
          }
          if (prop.key.name === "types") {
            state.stylexTypesImport.add(value.name);
          }
        }
      }
    }
  }
}

var lib = {};

var stylexCreate$1 = {};

var objectUtils = {};

var stylexInclude$1 = {};

var messages$4 = {};

Object.defineProperty(messages$4, "__esModule", {
  value: true
});
messages$4.UNKNOWN_PROP_KEY = messages$4.UNKNOWN_NAMESPACE = messages$4.UNEXPECTED_ARGUMENT = messages$4.UNBOUND_STYLEX_CALL_VALUE = messages$4.ONLY_TOP_LEVEL_INLCUDES = messages$4.ONLY_TOP_LEVEL = messages$4.NO_PROJECT_ROOT_DIRECTORY = messages$4.NO_PARENT_PATH = messages$4.NO_CONDITIONAL_SHORTHAND = messages$4.NON_STATIC_VALUE = messages$4.NON_OBJECT_FOR_STYLEX_CALL = messages$4.NON_EXPORT_NAMED_DECLARATION = messages$4.LOCAL_ONLY = messages$4.LINT_UNCLOSED_FUNCTION = messages$4.INVALID_SPREAD = messages$4.INVALID_PSEUDO_OR_AT_RULE = messages$4.INVALID_PSEUDO = messages$4.ILLEGAL_PROP_VALUE = messages$4.ILLEGAL_PROP_ARRAY_VALUE = messages$4.ILLEGAL_NESTED_PSEUDO = messages$4.ILLEGAL_NAMESPACE_VALUE = messages$4.ILLEGAL_NAMESPACE_TYPE = messages$4.ILLEGAL_ARGUMENT_LENGTH = messages$4.EXPECTED_FUNCTION_CALL = messages$4.ESCAPED_STYLEX_VALUE = messages$4.DUPLICATE_CONDITIONAL = void 0;
const ILLEGAL_ARGUMENT_LENGTH = "stylex() should have 1 argument.";
messages$4.ILLEGAL_ARGUMENT_LENGTH = ILLEGAL_ARGUMENT_LENGTH;
const NON_STATIC_VALUE = "Only static values are allowed inside of a stylex.create() call.";
messages$4.NON_STATIC_VALUE = NON_STATIC_VALUE;
const ESCAPED_STYLEX_VALUE = "Escaping a stylex.create() value is not allowed.";
messages$4.ESCAPED_STYLEX_VALUE = ESCAPED_STYLEX_VALUE;
const UNBOUND_STYLEX_CALL_VALUE = "stylex.create calls must be bound to a bare variable.";
messages$4.UNBOUND_STYLEX_CALL_VALUE = UNBOUND_STYLEX_CALL_VALUE;
const ONLY_TOP_LEVEL = "stylex.create() is only allowed at the root of a program.";
messages$4.ONLY_TOP_LEVEL = ONLY_TOP_LEVEL;
const NON_OBJECT_FOR_STYLEX_CALL = "stylex.create() can only accept a style object.";
messages$4.NON_OBJECT_FOR_STYLEX_CALL = NON_OBJECT_FOR_STYLEX_CALL;
const UNKNOWN_PROP_KEY = "Unknown property key";
messages$4.UNKNOWN_PROP_KEY = UNKNOWN_PROP_KEY;
const INVALID_PSEUDO = "Invalid pseudo selector, not on the whitelist.";
messages$4.INVALID_PSEUDO = INVALID_PSEUDO;
const INVALID_PSEUDO_OR_AT_RULE = "Invalid pseudo or at-rule.";
messages$4.INVALID_PSEUDO_OR_AT_RULE = INVALID_PSEUDO_OR_AT_RULE;
const NO_CONDITIONAL_SHORTHAND = "You cannot use conditional style values for a shorthand property.";
messages$4.NO_CONDITIONAL_SHORTHAND = NO_CONDITIONAL_SHORTHAND;
const ILLEGAL_NAMESPACE_TYPE = "Only a string literal namespace is allowed here.";
messages$4.ILLEGAL_NAMESPACE_TYPE = ILLEGAL_NAMESPACE_TYPE;
const UNKNOWN_NAMESPACE = "Unknown namespace";
messages$4.UNKNOWN_NAMESPACE = UNKNOWN_NAMESPACE;
const ILLEGAL_NESTED_PSEUDO = "Pseudo objects can't be nested more than one level deep.";
messages$4.ILLEGAL_NESTED_PSEUDO = ILLEGAL_NESTED_PSEUDO;
const ILLEGAL_PROP_VALUE = "A style value can only contain an array, string or number.";
messages$4.ILLEGAL_PROP_VALUE = ILLEGAL_PROP_VALUE;
const ILLEGAL_PROP_ARRAY_VALUE = "A style array value can only contain strings or numbers.";
messages$4.ILLEGAL_PROP_ARRAY_VALUE = ILLEGAL_PROP_ARRAY_VALUE;
const ILLEGAL_NAMESPACE_VALUE = "A stylex namespace must be an object.";
messages$4.ILLEGAL_NAMESPACE_VALUE = ILLEGAL_NAMESPACE_VALUE;
const INVALID_SPREAD = "Imported styles spread with a stylex.create call must be type cast as `XStyle<>` to verify their type.";
messages$4.INVALID_SPREAD = INVALID_SPREAD;
const LINT_UNCLOSED_FUNCTION = "Rule contains an unclosed function";
messages$4.LINT_UNCLOSED_FUNCTION = LINT_UNCLOSED_FUNCTION;
const LOCAL_ONLY = "The return value of stylex.create() should not be exported.";
messages$4.LOCAL_ONLY = LOCAL_ONLY;
const UNEXPECTED_ARGUMENT = "Unexpected argument passed to the stylex() function.";
messages$4.UNEXPECTED_ARGUMENT = UNEXPECTED_ARGUMENT;
const EXPECTED_FUNCTION_CALL = "Expected a simple function call but found something else.";
messages$4.EXPECTED_FUNCTION_CALL = EXPECTED_FUNCTION_CALL;
const NO_PARENT_PATH = "Unexpected AST node without a parent path.";
messages$4.NO_PARENT_PATH = NO_PARENT_PATH;
const ONLY_TOP_LEVEL_INLCUDES = "stylex.include() is only at the top level of a style definition object.";
messages$4.ONLY_TOP_LEVEL_INLCUDES = ONLY_TOP_LEVEL_INLCUDES;
const DUPLICATE_CONDITIONAL = "The same pseudo selector or at-rule cannot be used more than once.";
messages$4.DUPLICATE_CONDITIONAL = DUPLICATE_CONDITIONAL;
const NO_PROJECT_ROOT_DIRECTORY = "The project root directory `rootDir` is not configured.";
messages$4.NO_PROJECT_ROOT_DIRECTORY = NO_PROJECT_ROOT_DIRECTORY;
const NON_EXPORT_NAMED_DECLARATION = "The return value of stylex.createVars() must be bound to a named export.";
messages$4.NON_EXPORT_NAMED_DECLARATION = NON_EXPORT_NAMED_DECLARATION;

Object.defineProperty(stylexInclude$1, "__esModule", {
  value: true
});
stylexInclude$1.IncludedStyles = void 0;
stylexInclude$1.default = stylexInclude;
var messages$3 = _interopRequireWildcard$3(messages$4);
function _getRequireWildcardCache$3(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache$3 = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard$3(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache$3(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
let number$1 = 0;
function uuid() {
  return `__included_${++number$1}__`;
}
let IncludedStyles$1 = class IncludedStyles {
  constructor(astNode) {
    this.astNode = astNode;
  }
};
stylexInclude$1.IncludedStyles = IncludedStyles$1;
function stylexInclude(firstArg) {
  if ((arguments.length <= 1 ? 0 : arguments.length - 1) > 0) {
    throw new Error(messages$3.ILLEGAL_ARGUMENT_LENGTH);
  }
  return {
    [uuid()]: new IncludedStyles$1(firstArg.node)
  };
}

Object.defineProperty(objectUtils, "__esModule", {
  value: true
});
objectUtils.arraySort = objectUtils.arrayEquals = objectUtils.Pipe = void 0;
objectUtils.flattenObject = flattenObject;
objectUtils.isPlainObject = isPlainObject;
objectUtils.objEntries = objEntries;
objectUtils.objFromEntries = objFromEntries;
objectUtils.objMap = objMap;
objectUtils.objMapEntry = objMapEntry;
objectUtils.objMapKeys = objMapKeys;
objectUtils.objValues = objValues;
var _stylexInclude$4 = stylexInclude$1;
function isPlainObject(obj) {
  return typeof obj === "object" && obj != null && !Array.isArray(obj) && obj?.constructor === Object;
}
function flattenObject(obj) {
  const result = {};
  for (const [key, value] of objEntries(obj)) {
    if (typeof value === "string" || value == null) {
      result[key] = value;
    } else if (value instanceof _stylexInclude$4.IncludedStyles) {
      result[key] = value;
    } else {
      for (const [subKey, subValue] of objEntries(value)) {
        result[`${key}_${subKey}`] = subValue;
      }
    }
  }
  return result;
}
function objEntries(obj) {
  const retVal = [];
  for (const key of Object.keys(obj)) {
    retVal.push([key, obj[key]]);
  }
  return retVal;
}
function objValues(obj) {
  const retVal = [];
  for (const key of Object.keys(obj)) {
    retVal.push(obj[key]);
  }
  return retVal;
}
function objFromEntries(entries) {
  const retVal = {};
  for (const [key, value] of entries) {
    retVal[key] = value;
  }
  return retVal;
}
function objMapKeys(obj, mapper) {
  return objFromEntries(objEntries(obj).map(_ref => {
    let [key, value] = _ref;
    return [mapper(key), value];
  }));
}
function objMapEntry(obj, mapper) {
  return objFromEntries(objEntries(obj).map(_ref2 => {
    let [key, value] = _ref2;
    return mapper([key, value]);
  }));
}
function objMap(obj, mapper) {
  return objFromEntries(objEntries(obj).map(_ref3 => {
    let [key, value] = _ref3;
    return [key, mapper(value, key)];
  }));
}
class Pipe {
  constructor(val) {
    this.value = val;
  }
  pipe(mapper) {
    return new Pipe(mapper(this.value));
  }
  done() {
    return this.value;
  }
  static create(val) {
    return new Pipe(val);
  }
}
objectUtils.Pipe = Pipe;
const arraySort = (arr, fn) => [...arr].sort(fn);
objectUtils.arraySort = arraySort;
const arrayEquals = function (arr1, arr2) {
  let equals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (a, b) => a === b;
  if (arr1.length !== arr2.length) {
    return false;
  }
  for (let i = 0; i < arr1.length; i++) {
    if (!equals(arr1[i], arr2[i])) {
      return false;
    }
  }
  return true;
};
objectUtils.arrayEquals = arrayEquals;

var defaultOptions$1 = {};

Object.defineProperty(defaultOptions$1, "__esModule", {
  value: true
});
defaultOptions$1.defaultOptions = void 0;
const defaultOptions = {
  dev: false,
  test: false,
  classNamePrefix: "x",
  styleResolution: "application-order"
};
defaultOptions$1.defaultOptions = defaultOptions;

var flattenRawStyleObj = {};

var preprocessRules = {};

var applicationOrder = {};

var splitCssValue = {};

Object.defineProperty(splitCssValue, "__esModule", {
  value: true
});
splitCssValue.default = splitValue;
var _postcssValueParser$6 = _interopRequireDefault$k(require$$0);
function _interopRequireDefault$k(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function printNode(node) {
  switch (node.type) {
    case "word":
    case "string":
      return `${node.value}`;
    case "function":
      return `${node.value}(${node.nodes.map(printNode).join("")})`;
    default:
      return node.value;
  }
}
function splitValue(str) {
  if (str == null || typeof str === "number") {
    return [str];
  }
  if (Array.isArray(str)) {
    return str;
  }
  const parsed = (0, _postcssValueParser$6.default)(str.trim());
  const nodes = parsed.nodes.filter(node => node.type !== "space" && node.type !== "div").map(printNode);
  if (nodes.length > 1 && nodes[nodes.length - 1].toLowerCase() === "!important") {
    return nodes.slice(0, nodes.length - 1).map(node => node + " !important");
  }
  return nodes;
}

Object.defineProperty(applicationOrder, "__esModule", {
  value: true
});
applicationOrder.default = void 0;
var _splitCssValue$2 = _interopRequireDefault$j(splitCssValue);
function _interopRequireDefault$j(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const shorthands$2 = {
  all: _ => {
    throw new Error("all is not supported");
  },
  animation: value => [["animation", value], ["animationName", null], ["animationDuration", null], ["animationTimingFunction", null], ["animationDelay", null], ["animationIterationCount", null], ["animationDirection", null], ["animationFillMode", null], ["animationPlayState", null]],
  background: value => [["background", value], ["backgroundAttachment", null], ["backgroundClip", null], ["backgroundColor", null], ["backgroundImage", null], ["backgroundOrigin", null], ["backgroundPosition", null], ["backgroundRepeat", null], ["backgroundSize", null]],
  border: rawValue => {
    if (typeof rawValue === "number") {
      return shorthands$2.borderWidth(rawValue);
    }
    const [width, style, color] = (0, _splitCssValue$2.default)(rawValue);
    return [...shorthands$2.borderWidth(width), ...shorthands$2.borderStyle(style), ...shorthands$2.borderColor(color)];
  },
  borderInline: rawValue => {
    if (typeof rawValue === "number") {
      return [["borderInlineWidth", rawValue], ["borderInlineStartWidth", null], ["borderInlineEndWidth", null]];
    }
    const [width, style, color] = (0, _splitCssValue$2.default)(rawValue);
    return [...shorthands$2.borderInlineWidth(width), ...shorthands$2.borderInlineStyle(style), ...shorthands$2.borderInlineColor(color)];
  },
  borderBlock: rawValue => {
    if (typeof rawValue === "number") {
      return [["borderBlockWidth", rawValue], ["borderTopWidth", null], ["borderBottomWidth", null]];
    }
    const [width, style, color] = (0, _splitCssValue$2.default)(rawValue);
    return [...shorthands$2.borderBlockWidth(width), ...shorthands$2.borderBlockStyle(style), ...shorthands$2.borderBlockColor(color)];
  },
  borderTop: rawValue => {
    if (typeof rawValue === "number") {
      return [["borderTopWidth", rawValue]];
    }
    const [width, style, color] = (0, _splitCssValue$2.default)(rawValue);
    return [["borderTopWidth", width], ["borderTopStyle", style], ["borderTopColor", color]];
  },
  borderInlineEnd: rawValue => {
    if (typeof rawValue === "number") {
      return [["borderInlineEndWidth", rawValue]];
    }
    const [width, style, color] = (0, _splitCssValue$2.default)(rawValue);
    return [["borderInlineEndWidth", width], ["borderInlineEndStyle", style], ["borderInlineEndColor", color]];
  },
  borderRight: _rawValue => {
    throw new Error(["`borderRight` is not supported.", "You could use `borderRightWidth`, `borderRightStyle` and `borderRightColor`,", "but it is preferable to use `borderInlineEndWidth`, `borderInlineEndStyle` and `borderInlineEndColor`."].join(" "));
  },
  borderBottom: rawValue => {
    if (typeof rawValue === "number") {
      return [["borderBottomWidth", rawValue]];
    }
    const [width, style, color] = (0, _splitCssValue$2.default)(rawValue);
    return [["borderBottomWidth", width], ["borderBottomStyle", style], ["borderBottomColor", color]];
  },
  borderInlineStart: rawValue => {
    if (typeof rawValue === "number") {
      return [["borderInlineStartWidth", rawValue]];
    }
    const [width, style, color] = (0, _splitCssValue$2.default)(rawValue);
    return [["borderInlineStartWidth", width], ["borderInlineStartStyle", style], ["borderInlineStartColor", color]];
  },
  borderLeft: _rawValue => {
    throw new Error(["`borderLeft` is not supported.", "You could use `borderLeftWidth`, `borderLeftStyle` and `borderLeftColor`,", "but it is preferable to use `borderInlineStartWidth`, `borderInlineStartStyle` and `borderInlineStartColor`."].join(" "));
  },
  borderInlineWidth: rawValue => [["borderInlineWidth", rawValue], ["borderInlineStartWidth", null], ["borderLeftWidth", null], ["borderInlineEndWidth", null], ["borderRightWidth", null]],
  borderInlineStyle: rawValue => [["borderInlineStyle", rawValue], ["borderInlineStartStyle", null], ["borderLeftStyle", null], ["borderInlineEndStyle", null], ["borderRightStyle", null]],
  borderInlineColor: rawValue => [["borderInlineColor", rawValue], ["borderInlineStartColor", null], ["borderLeftColor", null], ["borderInlineEndColor", null], ["borderRightColor", null]],
  borderBlockWidth: rawValue => [["borderBlockWidth", rawValue], ["borderTopWidth", null], ["borderBottomWidth", null]],
  borderBlockStyle: rawValue => [["borderBlockStyle", rawValue], ["borderTopStyle", null], ["borderBottomStyle", null]],
  borderBlockColor: rawValue => [["borderBlockColor", rawValue], ["borderTopColor", null], ["borderBottomColor", null]],
  borderColor: value => [["borderColor", value], ["borderTopColor", null], ["borderInlineEndColor", null], ["borderRightColor", null], ["borderBottomColor", null], ["borderInlineStartColor", null], ["borderLeftColor", null]],
  borderStyle: value => [["borderStyle", value], ["borderTopStyle", null], ["borderInlineEndStyle", null], ["borderRightStyle", null], ["borderBottomStyle", null], ["borderInlineStartStyle", null], ["borderLeftStyle", null]],
  borderWidth: value => [["borderWidth", value], ["borderTopWidth", null], ["borderInlineEndWidth", null], ["borderRightWidth", null], ["borderBottomWidth", null], ["borderInlineStartWidth", null], ["borderLeftWidth", null]],
  borderInlineStartColor: value => [["borderInlineStartColor", value], ["borderLeftColor", null], ["borderRightColor", null]],
  borderInlineEndColor: value => [["borderInlineEndColor", value], ["borderLeftColor", null], ["borderRightColor", null]],
  borderInlineStartStyle: value => [["borderInlineStartStyle", value], ["borderLeftStyle", null], ["borderRightStyle", null]],
  borderInlineEndStyle: value => [["borderInlineEndStyle", value], ["borderLeftStyle", null], ["borderRightStyle", null]],
  borderInlineStartWidth: value => [["borderInlineStartWidth", value], ["borderLeftWidth", null], ["borderRightWidth", null]],
  borderInlineEndWidth: value => [["borderInlineEndWidth", value], ["borderLeftWidth", null], ["borderRightWidth", null]],
  borderLeftColor: value => [["borderLeftColor", value], ["borderInlineStartColor", null], ["borderInlineEndColor", null]],
  borderRightColor: value => [["borderRightColor", value], ["borderInlineStartColor", null], ["borderInlineEndColor", null]],
  borderLeftStyle: value => [["borderLeftStyle", value], ["borderInlineStartStyle", null], ["borderInlineEndStyle", null]],
  borderRightStyle: value => [["borderRightStyle", value], ["borderInlineStartStyle", null], ["borderInlineEndStyle", null]],
  borderLeftWidth: value => [["borderLeftWidth", value], ["borderInlineStartWidth", null], ["borderInlineEndWidth", null]],
  borderRightWidth: value => [["borderRightWidth", value], ["borderInlineStartWidth", null], ["borderInlineEndWidth", null]],
  borderRadius: value => {
    const values = typeof value === "number" ? [value] : (0, _splitCssValue$2.default)(value);
    if (values.length === 1) {
      return [["borderRadius", value], ["borderStartStartRadius", null], ["borderStartEndRadius", null], ["borderEndStartRadius", null], ["borderEndEndRadius", null], ["borderTopLeftRadius", null], ["borderTopRightRadius", null], ["borderBottomLeftRadius", null], ["borderBottomRightRadius", null]];
    }
    const [startStart, startEnd = startStart, endEnd = startStart, endStart = startEnd] = values;
    return [["borderStartStartRadius", startStart], ["borderStartEndRadius", startEnd], ["borderEndEndRadius", endEnd], ["borderEndStartRadius", endStart], ["borderTopLeftRadius", null], ["borderTopRightRadius", null], ["borderBottomLeftRadius", null], ["borderBottomRightRadius", null]];
  },
  borderStartStartRadius: value => [["borderStartStartRadius", value], ["borderTopLeftRadius", null], ["borderTopRightRadius", null]],
  borderStartEndRadius: value => [["borderStartEndRadius", value], ["borderTopLeftRadius", null], ["borderTopRightRadius", null]],
  borderEndStartRadius: value => [["borderEndStartRadius", value], ["borderBottomLeftRadius", null], ["borderBottomRightRadius", null]],
  borderEndEndRadius: value => [["borderEndEndRadius", value], ["borderBottomLeftRadius", null], ["borderBottomRightRadius", null]],
  borderTopLeftRadius: value => [["borderTopLeftRadius", value], ["borderStartStartRadius", null], ["borderStartEndRadius", null]],
  borderTopRightRadius: value => [["borderTopRightRadius", value], ["borderStartStartRadius", null], ["borderStartEndRadius", null]],
  borderBottomLeftRadius: value => [["borderBottomLeftRadius", value], ["borderEndStartRadius", null], ["borderEndEndRadius", null]],
  borderBottomRightRadius: value => [["borderBottomRightRadius", value], ["borderEndStartRadius", null], ["borderEndEndRadius", null]],
  columnRule: value => [["columnRule", value], ["columnRuleWidth", null], ["columnRuleStyle", null], ["columnRuleColor", null]],
  columns: value => [["columns", value], ["columnCount", null], ["columnWidth", null]],
  container: value => [["container", value], ["containerName", null], ["containerType", null]],
  flex: value => [["flex", value], ["flexGrow", null], ["flexShrink", null], ["flexBasis", null]],
  flexFlow: value => [["flexFlow", value], ["flexDirection", null], ["flexWrap", null]],
  font: value => [["font", value], ["fontFamily", null], ["fontSize", null], ["fontStretch", null], ["fontStyle", null], ["fontVariant", null], ["fontWeight", null], ["lineHeight", null]],
  gap: value => [["gap", value], ["rowGap", null], ["columnGap", null]],
  grid: value => [["grid", value], ["gridTemplate", null], ["gridTemplateAreas", null], ["gridTemplateColumns", null], ["gridTemplateRows", null], ["gridAutoRows", null], ["gridAutoColumns", null], ["gridAutoFlow", null]],
  gridArea: value => [["gridArea", value], ["gridRow", null], ["gridRowStart", null], ["gridRowEnd", null], ["gridColumn", null], ["gridColumnStart", null], ["gridColumnEnd", null]],
  gridRow: value => [["gridRow", value], ["gridRowStart", null], ["gridRowEnd", null]],
  gridColumn: value => [["gridColumn", value], ["gridColumnStart", null], ["gridColumnEnd", null]],
  gridTemplate: value => [["gridTemplate", value], ["gridTemplateAreas", null], ["gridTemplateColumns", null], ["gridTemplateRows", null]],
  inset: value => [["inset", value], ["insetInline", null], ["insetBlock", null], ["insetInlineStart", null], ["insetInlineEnd", null], ["top", null], ["right", null], ["bottom", null], ["left", null]],
  insetInline: value => [["insetInline", value], ["insetInlineStart", null], ["insetInlineEnd", null], ["left", null], ["right", null]],
  insetBlock: value => [["insetBlock", value], ["top", null], ["bottom", null]],
  insetInlineStart: value => [["insetInlineStart", value], ["left", null], ["right", null]],
  insetInlineEnd: value => [["insetInlineEnd", value], ["left", null], ["right", null]],
  left: value => [["left", value], ["insetInlineStart", null], ["insetInlineEnd", null]],
  right: value => [["right", value], ["insetInlineStart", null], ["insetInlineEnd", null]],
  listStyle: value => [["listStyle", value], ["listStyleImage", null], ["listStylePosition", null], ["listStyleType", null]],
  margin: value => {
    const values = typeof value === "number" ? [value] : (0, _splitCssValue$2.default)(value);
    if (values.length === 1) {
      return [["margin", values[0]], ["marginInlineStart", null], ["marginLeft", null], ["marginInlineEnd", null], ["marginRight", null], ["marginTop", null], ["marginBottom", null]];
    }
    const [top, right = top, bottom = top, left = right] = values;
    return [["marginTop", top], ["marginInlineEnd", right], ["marginBottom", bottom], ["marginInlineStart", left], ["marginLeft", null], ["marginRight", null]];
  },
  marginInline: value => [["marginInline", value], ["marginInlineStart", null], ["marginLeft", null], ["marginInlineEnd", null], ["marginRight", null]],
  marginBlock: value => [["marginBlock", value], ["marginTop", null], ["marginBottom", null]],
  marginInlineStart: value => [["marginInlineStart", value], ["marginLeft", null], ["marginRight", null]],
  marginInlineEnd: value => [["marginInlineEnd", value], ["marginLeft", null], ["marginRight", null]],
  marginLeft: value => [["marginLeft", value], ["marginInlineStart", null], ["marginInlineEnd", null]],
  marginRight: value => [["marginRight", value], ["marginInlineStart", null], ["marginInlineEnd", null]],
  mask: value => [["mask", value], ["maskClip", null], ["maskComposite", null], ["maskImage", null], ["maskMode", null], ["maskOrigin", null], ["maskPosition", null], ["maskRepeat", null], ["maskSize", null]],
  offset: value => [["offset", value], ["offsetAnchor", null], ["offsetDistance", null], ["offsetPath", null], ["offsetPosition", null], ["offsetRotate", null]],
  outline: value => [["outline", value], ["outlineColor", null], ["outlineStyle", null], ["outlineWidth", null]],
  overflow: value => [["overflow", value], ["overflowX", null], ["overflowY", null]],
  padding: rawValue => {
    const values = typeof rawValue === "number" ? [rawValue] : (0, _splitCssValue$2.default)(rawValue);
    if (values.length === 1) {
      return [["padding", values[0]], ["paddingStart", null], ["paddingLeft", null], ["paddingEnd", null], ["paddingRight", null], ["paddingTop", null], ["paddingBottom", null]];
    }
    const [top, right = top, bottom = top, left = right] = values;
    return [["paddingTop", top], ["paddingEnd", right], ["paddingBottom", bottom], ["paddingStart", left]];
  },
  paddingInline: rawValue => [["paddingInline", rawValue], ["paddingStart", null], ["paddingLeft", null], ["paddingEnd", null], ["paddingRight", null]],
  paddingBlock: rawValue => [["paddingBlock", rawValue], ["paddingTop", null], ["paddingBottom", null]],
  paddingInlineStart: value => [["paddingInlineStart", value], ["paddingLeft", null], ["paddingRight", null]],
  paddingInlineEnd: value => [["paddingInlineEnd", value], ["paddingLeft", null], ["paddingRight", null]],
  paddingLeft: value => [["paddingLeft", value], ["paddingInlineStart", null], ["paddingInlineEnd", null]],
  paddingRight: value => [["paddingRight", value], ["paddingInlineStart", null], ["paddingInlineEnd", null]],
  placeContent: value => [["placeContent", value], ["alignContent", null], ["justifyContent", null]],
  placeItems: value => [["placeItems", value], ["alignItems", null], ["justifyItems", null]],
  placeSelf: value => [["placeSelf", value], ["alignSelf", null], ["justifySelf", null]],
  scrollMargin: value => [["scrollMargin", value], ["scrollMarginBottom", null], ["scrollMarginLeft", null], ["scrollMarginStart", null], ["scrollMarginRight", null], ["scrollMarginEnd", null], ["scrollMarginTop", null]],
  scrollPadding: value => [["scrollPadding", value], ["scrollPaddingBottom", null], ["scrollPaddingLeft", null], ["scrollPaddingStart", null], ["scrollPaddingRight", null], ["scrollPaddingEnd", null], ["scrollPaddingTop", null]],
  scrollTimeline: value => [["scrollTimeline", value], ["scrollTimelineName", null], ["scrollTimelineAxis", null]],
  textDecoration: value => [["textDecoration", value], ["textDecorationColor", null], ["textDecorationLine", null], ["textDecorationStyle", null], ["textDecorationThickness", null]],
  textEmphasis: value => [["textEmphasis", value], ["textEmphasisColor", null], ["textEmphasisStyle", null]],
  transition: value => [["transition", value], ["transitionDelay", null], ["transitionDuration", null], ["transitionProperty", null], ["transitionTimingFunction", null]]
};
const aliases$2 = {
  borderHorizontal: shorthands$2.borderInline,
  borderVertical: shorthands$2.borderBlock,
  borderBlockStart: shorthands$2.borderTop,
  borderEnd: shorthands$2.borderInlineEnd,
  borderBlockEnd: shorthands$2.borderBottom,
  borderStart: shorthands$2.borderInlineStart,
  blockSize: val => [["height", val]],
  inlineSize: val => [["width", val]],
  minBlockSize: val => [["minHeight", val]],
  minInlineSize: val => [["minWidth", val]],
  maxBlockSize: val => [["maxHeight", val]],
  maxInlineSize: val => [["maxWidth", val]],
  borderHorizontalWidth: shorthands$2.borderInlineWidth,
  borderHorizontalStyle: shorthands$2.borderInlineStyle,
  borderHorizontalColor: shorthands$2.borderInlineColor,
  borderVerticalWidth: shorthands$2.borderBlockWidth,
  borderVerticalStyle: shorthands$2.borderBlockStyle,
  borderVerticalColor: shorthands$2.borderBlockColor,
  borderBlockStartColor: value => [["borderTopColor", value]],
  borderBlockEndColor: value => [["borderBottomColor", value]],
  borderBlockStartStyle: value => [["borderTopStyle", value]],
  borderBlockEndStyle: value => [["borderBottomStyle", value]],
  borderBlockStartWidth: value => [["borderTopWidth", value]],
  borderBlockEndWidth: value => [["borderBottomWidth", value]],
  borderStartColor: shorthands$2.borderInlineStartColor,
  borderEndColor: shorthands$2.borderInlineEndColor,
  borderStartStyle: shorthands$2.borderInlineStartStyle,
  borderEndStyle: shorthands$2.borderInlineEndStyle,
  borderStartWidth: shorthands$2.borderInlineStartWidth,
  borderEndWidth: shorthands$2.borderInlineEndWidth,
  borderTopStartRadius: value => [["borderStartStartRadius", value]],
  borderTopEndRadius: value => [["borderStartEndRadius", value]],
  borderBottomStartRadius: value => [["borderEndStartRadius", value]],
  borderBottomEndRadius: value => [["borderEndEndRadius", value]],
  marginBlockStart: value => [["marginTop", value]],
  marginBlockEnd: value => [["marginBottom", value]],
  marginStart: shorthands$2.marginInlineStart,
  marginEnd: shorthands$2.marginInlineEnd,
  marginHorizontal: shorthands$2.marginInline,
  marginVertical: shorthands$2.marginBlock,
  paddingBlockStart: rawValue => [["paddingTop", rawValue]],
  paddingBlockEnd: rawValue => [["paddingBottom", rawValue]],
  paddingStart: shorthands$2.paddingInlineStart,
  paddingEnd: shorthands$2.paddingInlineEnd,
  paddingHorizontal: shorthands$2.paddingInline,
  paddingVertical: shorthands$2.paddingBlock,
  insetBlockStart: value => [["top", value]],
  insetBlockEnd: value => [["bottom", value]],
  start: shorthands$2.insetInlineStart,
  end: shorthands$2.insetInlineEnd
};
const expansions$3 = {
  ...shorthands$2,
  ...aliases$2
};
var _default$4 = expansions$3;
applicationOrder.default = _default$4;

var legacyExpandShorthands = {};

Object.defineProperty(legacyExpandShorthands, "__esModule", {
  value: true
});
legacyExpandShorthands.default = void 0;
var _splitCssValue$1 = _interopRequireDefault$i(splitCssValue);
function _interopRequireDefault$i(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const shorthands$1 = {
  border: rawValue => {
    return [["borderTop", rawValue], ["borderEnd", rawValue], ["borderBottom", rawValue], ["borderStart", rawValue]];
  },
  borderColor: rawValue => {
    const [top, right = top, bottom = top, left = right] = (0, _splitCssValue$1.default)(rawValue);
    return [["borderTopColor", top], ["borderEndColor", right], ["borderBottomColor", bottom], ["borderStartColor", left]];
  },
  borderHorizontal: rawValue => {
    return [["borderStart", rawValue], ["borderEnd", rawValue]];
  },
  borderStyle: rawValue => {
    const [top, right = top, bottom = top, left = right] = (0, _splitCssValue$1.default)(rawValue);
    return [["borderTopStyle", top], ["borderEndStyle", right], ["borderBottomStyle", bottom], ["borderStartStyle", left]];
  },
  borderVertical: rawValue => {
    return [["borderTop", rawValue], ["borderBottom", rawValue]];
  },
  borderWidth: rawValue => {
    const [top, right = top, bottom = top, left = right] = (0, _splitCssValue$1.default)(rawValue);
    return [["borderTopWidth", top], ["borderEndWidth", right], ["borderBottomWidth", bottom], ["borderStartWidth", left]];
  },
  borderHorizontalColor: rawValue => [["borderStartColor", rawValue], ["borderEndColor", rawValue]],
  borderHorizontalStyle: rawValue => [["borderStartStyle", rawValue], ["borderEndStyle", rawValue]],
  borderHorizontalWidth: rawValue => [["borderStartWidth", rawValue], ["borderEndWidth", rawValue]],
  borderVerticalColor: rawValue => [["borderTopColor", rawValue], ["borderBottomColor", rawValue]],
  borderVerticalStyle: rawValue => [["borderTopStyle", rawValue], ["borderBottomStyle", rawValue]],
  borderVerticalWidth: rawValue => [["borderTopWidth", rawValue], ["borderBottomWidth", rawValue]],
  borderRadius: rawValue => {
    const [top, right = top, bottom = top, left = right] = (0, _splitCssValue$1.default)(rawValue);
    return [["borderTopStartRadius", top], ["borderTopEndRadius", right], ["borderBottomEndRadius", bottom], ["borderBottomStartRadius", left]];
  },
  inset: rawValue => [["top", rawValue], ["end", rawValue], ["bottom", rawValue], ["start", rawValue]],
  insetInline: rawValue => [["start", rawValue], ["end", rawValue]],
  insetBlock: rawValue => [["top", rawValue], ["bottom", rawValue]],
  margin: rawValue => {
    const [top, right = top, bottom = top, left = right] = (0, _splitCssValue$1.default)(rawValue);
    return [["marginTop", top], ["marginEnd", right], ["marginBottom", bottom], ["marginStart", left]];
  },
  marginHorizontal: rawValue => {
    return [["marginStart", rawValue], ["marginEnd", rawValue]];
  },
  marginVertical: rawValue => {
    return [["marginTop", rawValue], ["marginBottom", rawValue]];
  },
  overflow: rawValue => {
    const [x, y = x] = (0, _splitCssValue$1.default)(rawValue);
    return [["overflowX", x], ["overflowY", y]];
  },
  padding: rawValue => {
    const [top, right = top, bottom = top, left = right] = (0, _splitCssValue$1.default)(rawValue);
    return [["paddingTop", top], ["paddingEnd", right], ["paddingBottom", bottom], ["paddingStart", left]];
  },
  paddingHorizontal: val => {
    return [["paddingStart", val], ["paddingEnd", val]];
  },
  paddingVertical: val => {
    return [["paddingTop", val], ["paddingBottom", val]];
  }
};
const aliases$1 = {
  insetBlockStart: val => [["top", val]],
  insetBlockEnd: val => [["bottom", val]],
  insetInlineStart: val => [["start", val]],
  insetInlineEnd: val => [["end", val]],
  blockSize: val => [["height", val]],
  inlineSize: val => [["width", val]],
  minBlockSize: val => [["minHeight", val]],
  minInlineSize: val => [["minWidth", val]],
  maxBlockSize: val => [["maxHeight", val]],
  maxInlineSize: val => [["maxWidth", val]],
  borderBlockWidth: shorthands$1.borderVerticalWidth,
  borderBlockStyle: shorthands$1.borderVerticalStyle,
  borderBlockColor: shorthands$1.borderVerticalColor,
  borderBlockStartWidth: val => [["borderTopWidth", val]],
  borderBlockStartStyle: val => [["borderTopStyle", val]],
  borderBlockStartColor: val => [["borderTopColor", val]],
  borderBlockEndWidth: val => [["borderBottomWidth", val]],
  borderBlockEndStyle: val => [["borderBottomStyle", val]],
  borderBlockEndColor: val => [["borderBottomColor", val]],
  borderInlineWidth: shorthands$1.borderHorizontalWidth,
  borderInlineStyle: shorthands$1.borderHorizontalStyle,
  borderInlineColor: shorthands$1.borderHorizontalColor,
  borderInlineStartWidth: val => [["borderStartWidth", val]],
  borderInlineStartStyle: val => [["borderStartStyle", val]],
  borderInlineStartColor: val => [["borderStartColor", val]],
  borderInlineEndWidth: val => [["borderEndWidth", val]],
  borderInlineEndStyle: val => [["borderEndStyle", val]],
  borderInlineEndColor: val => [["borderEndColor", val]],
  borderStartStartRadius: val => [["borderTopStartRadius", val]],
  borderStartEndRadius: val => [["borderTopEndRadius", val]],
  borderEndStartRadius: val => [["borderBottomStartRadius", val]],
  borderEndEndRadius: val => [["borderBottomEndRadius", val]],
  marginBlock: shorthands$1.marginVertical,
  marginBlockStart: val => [["marginTop", val]],
  marginBlockEnd: val => [["marginBottom", val]],
  marginInline: shorthands$1.marginHorizontal,
  marginInlineStart: val => [["marginStart", val]],
  marginInlineEnd: val => [["marginEnd", val]],
  paddingBlock: shorthands$1.paddingVertical,
  paddingBlockStart: val => [["paddingTop", val]],
  paddingBlockEnd: val => [["paddingBottom", val]],
  paddingInline: shorthands$1.paddingHorizontal,
  paddingInlineStart: val => [["paddingStart", val]],
  paddingInlineEnd: val => [["paddingEnd", val]]
};
const expansions$2 = {
  ...shorthands$1,
  ...aliases$1
};
var _default$3 = expansions$2;
legacyExpandShorthands.default = _default$3;

var propertySpecificity = {};

Object.defineProperty(propertySpecificity, "__esModule", {
  value: true
});
propertySpecificity.default = void 0;
var _splitCssValue = _interopRequireDefault$h(splitCssValue);
function _interopRequireDefault$h(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const shorthands = {
  all: _ => {
    throw new Error("all is not supported");
  },
  animation: _value => {
    throw new Error("animation is not supported");
  },
  background: _value => {
    throw new Error("background is not supported. Use background-color, border-image etc. instead.");
  },
  border: _rawValue => {
    throw new Error("border is not supported. Use border-width, border-style and border-color instead.");
  },
  borderInline: _rawValue => {
    throw new Error("borderInline is not supported. Use borderInlineWidth, borderInlineStyle and borderInlineColor instead.");
  },
  borderBlock: _rawValue => {
    throw new Error("borderBlock is not supported. Use borderBlockWidth, borderBlockStyle and borderBlockColor instead.");
  },
  borderTop: _rawValue => {
    throw new Error("borderTop is not supported. Use borderTopWidth, borderTopStyle and borderTopColor instead.");
  },
  borderInlineEnd: _rawValue => {
    throw new Error("borderInlineEnd is not supported. Use borderInlineEndWidth, borderInlineEndStyle and borderInlineEndColor instead.");
  },
  borderRight: _rawValue => {
    throw new Error("borderRight is not supported. Use borderRightWidth, borderRightStyle and borderRightColor instead.");
  },
  borderBottom: _rawValue => {
    throw new Error("borderBottom is not supported. Use borderBottomWidth, borderBottomStyle and borderBottomColor instead.");
  },
  borderInlineStart: _rawValue => {
    throw new Error("borderInlineStart is not supported. Use borderInlineStartWidth, borderInlineStartStyle and borderInlineStartColor instead.");
  },
  borderLeft: _rawValue => {
    throw new Error(["`borderLeft` is not supported.", "You could use `borderLeftWidth`, `borderLeftStyle` and `borderLeftColor`,", "but it is preferable to use `borderInlineStartWidth`, `borderInlineStartStyle` and `borderInlineStartColor`."].join(" "));
  },
  margin: value => {
    const values = (0, _splitCssValue.default)(value);
    if (values.length === 1) {
      return [["margin", values[0]]];
    } else {
      throw new Error("margin shorthand with multiple values is not supported. Use marginTop, marginInlineEnd, marginBottom and marginInlineStart instead.");
    }
  },
  padding: rawValue => {
    const values = (0, _splitCssValue.default)(rawValue);
    if (values.length === 1) {
      return [["padding", values[0]]];
    }
    throw new Error("padding shorthand with multiple values is not supported. Use paddingTop, paddingInlineEnd, paddingBottom and paddingInlineStart instead.");
  }
};
const aliases = {
  borderHorizontal: shorthands.borderInline,
  borderVertical: shorthands.borderBlock,
  borderBlockStart: shorthands.borderTop,
  borderEnd: shorthands.borderInlineEnd,
  borderBlockEnd: shorthands.borderBottom,
  borderStart: shorthands.borderInlineStart,
  blockSize: val => [["height", val]],
  inlineSize: val => [["width", val]],
  minBlockSize: val => [["minHeight", val]],
  minInlineSize: val => [["minWidth", val]],
  maxBlockSize: val => [["maxHeight", val]],
  maxInlineSize: val => [["maxWidth", val]],
  borderHorizontalWidth: value => [["borderInlineWidth", value]],
  borderHorizontalStyle: value => [["borderInlineStyle", value]],
  borderHorizontalColor: value => [["borderInlineColor", value]],
  borderVerticalWidth: value => [["borderBlockWidth", value]],
  borderVerticalStyle: value => [["borderBlockStyle", value]],
  borderVerticalColor: value => [["borderBlockColor", value]],
  borderBlockStartColor: value => [["borderTopColor", value]],
  borderBlockEndColor: value => [["borderBottomColor", value]],
  borderBlockStartStyle: value => [["borderTopStyle", value]],
  borderBlockEndStyle: value => [["borderBottomStyle", value]],
  borderBlockStartWidth: value => [["borderTopWidth", value]],
  borderBlockEndWidth: value => [["borderBottomWidth", value]],
  borderStartColor: value => [["borderInlineStartColor", value]],
  borderEndColor: value => [["borderInlineEndColor", value]],
  borderStartStyle: value => [["borderInlineStartStyle", value]],
  borderEndStyle: value => [["borderInlineEndStyle", value]],
  borderStartWidth: value => [["borderInlineStartWidth", value]],
  borderEndWidth: value => [["borderInlineEndWidth", value]],
  borderTopStartRadius: value => [["borderStartStartRadius", value]],
  borderTopEndRadius: value => [["borderStartEndRadius", value]],
  borderBottomStartRadius: value => [["borderEndStartRadius", value]],
  borderBottomEndRadius: value => [["borderEndEndRadius", value]],
  marginBlockStart: value => [["marginTop", value]],
  marginBlockEnd: value => [["marginBottom", value]],
  marginStart: value => [["marginInlineStart", value]],
  marginEnd: value => [["marginInlineEnd", value]],
  marginHorizontal: value => [["marginInline", value]],
  marginVertical: value => [["marginBlock", value]],
  paddingBlockStart: rawValue => [["paddingTop", rawValue]],
  paddingBlockEnd: rawValue => [["paddingBottom", rawValue]],
  paddingStart: value => [["paddingInlineStart", value]],
  paddingEnd: value => [["paddingInlineEnd", value]],
  paddingHorizontal: value => [["paddingInline", value]],
  paddingVertical: value => [["paddingBlock", value]],
  insetBlockStart: value => [["top", value]],
  insetBlockEnd: value => [["bottom", value]],
  start: value => [["insetInlineStart", value]],
  end: value => [["insetInlineEnd", value]]
};
const expansions$1 = {
  ...shorthands,
  ...aliases
};
var _default$2 = expansions$1;
propertySpecificity.default = _default$2;

Object.defineProperty(preprocessRules, "__esModule", {
  value: true
});
preprocessRules.default = flatMapExpandedShorthands;
preprocessRules.getExpandedKeys = getExpandedKeys;
var _applicationOrder = _interopRequireDefault$g(applicationOrder);
var _legacyExpandShorthands = _interopRequireDefault$g(legacyExpandShorthands);
var _propertySpecificity = _interopRequireDefault$g(propertySpecificity);
function _interopRequireDefault$g(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const expansions = {
  "application-order": _applicationOrder.default,
  "property-specificity": _propertySpecificity.default,
  "legacy-expand-shorthands": _legacyExpandShorthands.default
};
function getExpandedKeys(options) {
  return Object.keys(expansions[options.styleResolution ?? "application-order"]);
}
function flatMapExpandedShorthands(objEntry, options) {
  const [key, value] = objEntry;
  const expansion = expansions[options.styleResolution ?? "application-order"][key];
  if (expansion) {
    if (Array.isArray(value)) {
      throw new Error("Cannot use fallbacks for shorthands. Use the expansion instead.");
    }
    return expansion(value);
  }
  return [[key, value]];
}

var PreRule$1 = {};

var convertToClassName = {};

var hash$1 = {};

Object.defineProperty(hash$1, "__esModule", {
  value: true
});
hash$1.default = void 0;
function murmurhash2_32_gc(str) {
  let seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let l = str.length,
    h = seed ^ l,
    i = 0,
    k;
  while (l >= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = (k & 65535) * 1540483477 + (((k >>> 16) * 1540483477 & 65535) << 16);
    k ^= k >>> 24;
    k = (k & 65535) * 1540483477 + (((k >>> 16) * 1540483477 & 65535) << 16);
    h = (h & 65535) * 1540483477 + (((h >>> 16) * 1540483477 & 65535) << 16) ^ k;
    l -= 4;
    ++i;
  }
  switch (l) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255;
      h = (h & 65535) * 1540483477 + (((h >>> 16) * 1540483477 & 65535) << 16);
  }
  h ^= h >>> 13;
  h = (h & 65535) * 1540483477 + (((h >>> 16) * 1540483477 & 65535) << 16);
  h ^= h >>> 15;
  return h >>> 0;
}
const hash = str => murmurhash2_32_gc(str, 1).toString(36);
var _default$1 = hash;
hash$1.default = _default$1;

var dashify$1 = {};

Object.defineProperty(dashify$1, "__esModule", {
  value: true
});
dashify$1.default = dashify;
function dashify(str) {
  return str.replace(/(^|[a-z])([A-Z])/g, "$1-$2").toLowerCase();
}

var transformValue$1 = {};

var normalizeValue$1 = {};

var fontSizePxToRem = {};

Object.defineProperty(fontSizePxToRem, "__esModule", {
  value: true
});
fontSizePxToRem.default = convertFontSizeToRem;
var _postcssValueParser$5 = _interopRequireDefault$f(require$$0);
function _interopRequireDefault$f(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ROOT_FONT_SIZE = 16;
function convertFontSizeToRem(ast, key) {
  if (key !== "fontSize") {
    return ast;
  }
  ast.walk(node => {
    if (node.type !== "word") {
      return;
    }
    const dimension = _postcssValueParser$5.default.unit(node.value);
    if (dimension && dimension.unit === "px") {
      node.value = `${parseFloat(dimension.number) / ROOT_FONT_SIZE}rem`;
    }
  });
  return ast;
}

var leadingZero = {};

Object.defineProperty(leadingZero, "__esModule", {
  value: true
});
leadingZero.default = normalizeLeadingZero;
var _postcssValueParser$4 = _interopRequireDefault$e(require$$0);
function _interopRequireDefault$e(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function normalizeLeadingZero(ast, _) {
  ast.walk(node => {
    if (node.type !== "word") {
      return;
    }
    const value = Number.parseFloat(node.value);
    if (Number.isNaN(value)) {
      return;
    }
    const dimension = _postcssValueParser$4.default.unit(node.value);
    if (value < 1 && value >= 0) {
      node.value = value.toString().replace("0.", ".") + (dimension ? dimension.unit : "");
    }
  });
  return ast;
}

var quotes = {};

Object.defineProperty(quotes, "__esModule", {
  value: true
});
quotes.default = normalizeQuotes;
function normalizeQuotes(ast, _) {
  ast.walk(node => {
    if (node.type !== "string") {
      return;
    }
    if (node.value === "") {
      node.quote = "\"";
    }
  });
  return ast;
}

var timings$1 = {};

Object.defineProperty(timings$1, "__esModule", {
  value: true
});
timings$1.default = normalizeTimings;
var _postcssValueParser$3 = _interopRequireDefault$d(require$$0);
function _interopRequireDefault$d(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function normalizeTimings(ast, _) {
  ast.walk(node => {
    if (node.type !== "word") {
      return;
    }
    const value = Number.parseFloat(node.value);
    if (Number.isNaN(value)) {
      return;
    }
    const dimension = _postcssValueParser$3.default.unit(node.value);
    if (!dimension || dimension.unit !== "ms" || value < 10) {
      return;
    }
    node.value = value / 1000 + "s";
  });
  return ast;
}

var whitespace = {};

Object.defineProperty(whitespace, "__esModule", {
  value: true
});
whitespace.default = normalizeWhitespace;
function normalizeWhitespace(ast, _) {
  if (ast.nodes[0].type === "space") {
    ast.nodes.shift();
  }
  if (ast.nodes[ast.nodes.length - 1].type === "space") {
    ast.nodes.pop();
  }
  ast.walk((node, idx) => {
    switch (node.type) {
      case "space":
        {
          node.value = " ";
          break;
        }
      case "div":
      case "function":
        {
          node.before = "";
          node.after = "";
          break;
        }
      case "word":
        {
          if (node.value === "!important") {
            if (ast.nodes[idx - 1] && ast.nodes[idx - 1].type === "space") {
              ast.nodes.splice(idx - 1, 1);
            }
          }
          break;
        }
    }
  });
  return ast;
}

var zeroDimensions = {};

Object.defineProperty(zeroDimensions, "__esModule", {
  value: true
});
zeroDimensions.default = normalizeZeroDimensions;
var _postcssValueParser$2 = _interopRequireDefault$c(require$$0);
function _interopRequireDefault$c(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const angles = ["deg", "grad", "turn", "rad"];
const timings = ["ms", "s"];
function normalizeZeroDimensions(ast, _) {
  ast.walk(node => {
    if (node.type !== "word") {
      return;
    }
    const dimension = _postcssValueParser$2.default.unit(node.value);
    if (!dimension || dimension.number !== "0") {
      return;
    }
    if (angles.indexOf(dimension.unit) !== -1) {
      node.value = "0deg";
    } else if (timings.indexOf(dimension.unit) !== -1) {
      node.value = "0s";
    } else {
      node.value = "0";
    }
  });
  return ast;
}

var detectUnclosedFns$1 = {};

Object.defineProperty(detectUnclosedFns$1, "__esModule", {
  value: true
});
detectUnclosedFns$1.default = detectUnclosedFns;
var messages$2 = _interopRequireWildcard$2(messages$4);
function _getRequireWildcardCache$2(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache$2 = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard$2(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache$2(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function detectUnclosedFns(ast, _) {
  ast.walk(node => {
    if (node.type === "function" && node.unclosed) {
      throw new Error(messages$2.LINT_UNCLOSED_FUNCTION);
    }
  });
  return ast;
}

Object.defineProperty(normalizeValue$1, "__esModule", {
  value: true
});
normalizeValue$1.default = normalizeValue;
var _fontSizePxToRem = _interopRequireDefault$b(fontSizePxToRem);
var _leadingZero = _interopRequireDefault$b(leadingZero);
var _quotes = _interopRequireDefault$b(quotes);
var _timings = _interopRequireDefault$b(timings$1);
var _whitespace = _interopRequireDefault$b(whitespace);
var _zeroDimensions = _interopRequireDefault$b(zeroDimensions);
var _detectUnclosedFns = _interopRequireDefault$b(detectUnclosedFns$1);
var _postcssValueParser$1 = _interopRequireDefault$b(require$$0);
function _interopRequireDefault$b(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const normalizers = [_detectUnclosedFns.default, _whitespace.default, _timings.default, _zeroDimensions.default, _leadingZero.default, _quotes.default, _fontSizePxToRem.default];
function normalizeValue(value, key) {
  if (value == null) {
    return value;
  }
  const parsedAST = (0, _postcssValueParser$1.default)(value);
  return normalizers.reduce((ast, fn) => fn(ast, key), parsedAST).toString();
}

Object.defineProperty(transformValue$1, "__esModule", {
  value: true
});
transformValue$1.default = transformValue;
var getNumberSuffix_1 = transformValue$1.getNumberSuffix = getNumberSuffix;
var timeUnits_1 = transformValue$1.timeUnits = lengthUnits_1 = transformValue$1.lengthUnits = void 0;
var _normalizeValue = _interopRequireDefault$a(normalizeValue$1);
function _interopRequireDefault$a(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function transformValue(key, rawValue) {
  const value = typeof rawValue === "number" ? String(Math.round(rawValue * 10000) / 10000) + getNumberSuffix(key) : rawValue;
  if (key === "content" && typeof value === "string") {
    const val = value.trim();
    if (val.match(/^attr\([a-zA-Z0-9-]+\)$/)) {
      return val;
    }
    if (!(val.startsWith("\"") && val.endsWith("\"") || val.startsWith("'") && val.endsWith("'"))) {
      return `"${val}"`;
    }
  }
  return (0, _normalizeValue.default)(value, key);
}
function getNumberSuffix(key) {
  if (unitlessNumberProperties.has(key)) {
    return "";
  }
  const suffix = numberPropertySuffixes[key];
  if (suffix == null) {
    return "px";
  } else {
    return suffix;
  }
}
const unitlessNumberProperties = new Set(["animationIterationCount", "aspectRatio", "borderImageOutset", "borderImageSlice", "borderImageWidth", "columnCount", "flex", "flexGrow", "flexPositive", "flexShrink", "flexOrder", "gridRow", "gridColumn", "fontWeight", "lineClamp", "lineHeight", "opacity", "order", "orphans", "tabSize", "widows", "zIndex", "fillOpacity", "floodOpacity", "stopOpacity", "strokeDasharray", "strokeDashoffset", "strokeMiterlimit", "strokeOpacity", "strokeWidth"]);
const numberPropertySuffixes = {
  animationDelay: "ms",
  animationDuration: "ms",
  transitionDelay: "ms",
  transitionDuration: "ms",
  voiceDuration: "ms"
};
const timeUnits = new Set(Object.keys(numberPropertySuffixes));
timeUnits_1 = transformValue$1.timeUnits = timeUnits;
const lengthUnits = new Set(["backgroundPositionX", "backgroundPositionY", "blockSize", "borderBlockEndWidth", "borderBlockStartWidth", "borderBlockWidth", "borderVerticalWidth", "borderVerticalWidth", "borderBottomLeftRadius", "borderBottomRightRadius", "borderBottomWidth", "borderEndEndRadius", "borderEndStartRadius", "borderImageWidth", "borderInlineEndWidth", "borderEndWidth", "borderInlineStartWidth", "borderStartWidth", "borderInlineWidth", "borderHorizontalWidth", "borderLeftWidth", "borderRightWidth", "borderSpacing", "borderStartEndRadius", "borderStartStartRadius", "borderTopLeftRadius", "borderTopRightRadius", "borderTopWidth", "bottom", "columnGap", "columnRuleWidth", "columnWidth", "containIntrinsicBlockSize", "containIntrinsicHeight", "containIntrinsicInlineSize", "containIntrinsicWidth", "flexBasis", "fontSize", "fontSmooth", "height", "inlineSize", "insetBlockEnd", "insetBlockStart", "insetInlineEnd", "insetInlineStart", "left", "letterSpacing", "marginBlockEnd", "marginBlockStart", "marginBottom", "marginInlineEnd", "marginEnd", "marginInlineStart", "marginStart", "marginLeft", "marginRight", "marginTop", "maskBorderOutset", "maskBorderWidth", "maxBlockSize", "maxHeight", "maxInlineSize", "maxWidth", "minBlockSize", "minHeight", "minInlineSize", "minWidth", "offsetDistance", "outlineOffset", "outlineWidth", "overflowClipMargin", "paddingBlockEnd", "paddingBlockStart", "paddingBottom", "paddingInlineEnd", "paddingEnd", "paddingInlineStart", "paddingStart", "paddingLeft", "paddingRight", "paddingTop", "perspective", "right", "rowGap", "scrollMarginBlockEnd", "scrollMarginBlockStart", "scrollMarginBottom", "scrollMarginInlineEnd", "scrollMarginInlineStart", "scrollMarginLeft", "scrollMarginRight", "scrollMarginTop", "scrollPaddingBlockEnd", "scrollPaddingBlockStart", "scrollPaddingBottom", "scrollPaddingInlineEnd", "scrollPaddingInlineStart", "scrollPaddingLeft", "scrollPaddingRight", "scrollPaddingTop", "scrollSnapMarginBottom", "scrollSnapMarginLeft", "scrollSnapMarginRight", "scrollSnapMarginTop", "shapeMargin", "tabSize", "textDecorationThickness", "textIndent", "textUnderlineOffset", "top", "transformOrigin", "translate", "verticalAlign", "width", "wordSpacing", "border", "borderBlock", "borderBlockEnd", "borderBlockStart", "borderBottom", "borderLeft", "borderRadius", "borderRight", "borderTop", "borderWidth", "columnRule", "containIntrinsicSize", "gap", "inset", "insetBlock", "insetInline", "margin", "marginBlock", "marginVertical", "marginInline", "marginHorizontal", "offset", "outline", "padding", "paddingBlock", "paddingVertical", "paddingInline", "paddingHorizontal", "scrollMargin", "scrollMarginBlock", "scrollMarginInline", "scrollPadding", "scrollPaddingBlock", "scrollPaddingInline", "scrollSnapMargin"]);
var lengthUnits_1 = transformValue$1.lengthUnits = lengthUnits;

var generateCssRule = {};

var generateLtr = {};

Object.defineProperty(generateLtr, "__esModule", {
  value: true
});
generateLtr.default = generateLTR;
const logicalToPhysical$1 = {
  start: "left",
  end: "right"
};
const propertyToLTR = {
  "margin-start": _ref => {
    let [_key, val] = _ref;
    return ["margin-left", val];
  },
  "margin-end": _ref2 => {
    let [_key, val] = _ref2;
    return ["margin-right", val];
  },
  "padding-start": _ref3 => {
    let [_key, val] = _ref3;
    return ["padding-left", val];
  },
  "padding-end": _ref4 => {
    let [_key, val] = _ref4;
    return ["padding-right", val];
  },
  "border-start": _ref5 => {
    let [_key, val] = _ref5;
    return ["border-left", val];
  },
  "border-end": _ref6 => {
    let [_key, val] = _ref6;
    return ["border-right", val];
  },
  "border-start-width": _ref7 => {
    let [_key, val] = _ref7;
    return ["border-left-width", val];
  },
  "border-end-width": _ref8 => {
    let [_key, val] = _ref8;
    return ["border-right-width", val];
  },
  "border-start-color": _ref9 => {
    let [_key, val] = _ref9;
    return ["border-left-color", val];
  },
  "border-end-color": _ref10 => {
    let [_key, val] = _ref10;
    return ["border-right-color", val];
  },
  "border-start-style": _ref11 => {
    let [_key, val] = _ref11;
    return ["border-left-style", val];
  },
  "border-end-style": _ref12 => {
    let [_key, val] = _ref12;
    return ["border-right-style", val];
  },
  "border-top-start-radius": _ref13 => {
    let [_key, val] = _ref13;
    return ["border-top-left-radius", val];
  },
  "border-bottom-start-radius": _ref14 => {
    let [_key, val] = _ref14;
    return ["border-bottom-left-radius", val];
  },
  "border-top-end-radius": _ref15 => {
    let [_key, val] = _ref15;
    return ["border-top-right-radius", val];
  },
  "border-bottom-end-radius": _ref16 => {
    let [_key, val] = _ref16;
    return ["border-bottom-right-radius", val];
  },
  "text-align": _ref17 => {
    let [key, val] = _ref17;
    return [key, logicalToPhysical$1[val] ?? val];
  },
  float: _ref18 => {
    let [key, val] = _ref18;
    return [key, logicalToPhysical$1[val] ?? val];
  },
  clear: _ref19 => {
    let [key, val] = _ref19;
    return [key, logicalToPhysical$1[val] ?? val];
  },
  start: _ref20 => {
    let [_key, val] = _ref20;
    return ["left", val];
  },
  end: _ref21 => {
    let [_key, val] = _ref21;
    return ["right", val];
  },
  "background-position": _ref22 => {
    let [key, val] = _ref22;
    return [key, val.split(" ").map(word => word === "start" ? "left" : word === "end" ? "right" : word).join(" ")];
  }
};
function generateLTR(pair) {
  const [key] = pair;
  if (propertyToLTR[key]) {
    return propertyToLTR[key](pair);
  }
  return pair;
}

var generateRtl = {};

Object.defineProperty(generateRtl, "__esModule", {
  value: true
});
generateRtl.default = generateRTL;
var _postcssValueParser = _interopRequireDefault$9(require$$0);
function _interopRequireDefault$9(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const cursorFlip = {
  "e-resize": "w-resize",
  "w-resize": "e-resize",
  "ne-resize": "nw-resize",
  "nesw-resize": "nwse-resize",
  "nw-resize": "ne-resize",
  "nwse-resize": "nesw-resize",
  "se-resize": "sw-resize",
  "sw-resize": "se-resize"
};
function splitByDivisor(value) {
  const ast = (0, _postcssValueParser.default)(value);
  const groups = [];
  let currGroup = [];
  function push() {
    if (currGroup.length === 0) {
      return;
    }
    groups.push(_postcssValueParser.default.stringify(currGroup));
    currGroup = [];
  }
  for (const node of ast.nodes) {
    if (node.type === "div") {
      push();
    } else {
      currGroup.push(node);
    }
  }
  push();
  return groups;
}
function flipSign(value) {
  if (value === "0") {
    return value;
  } else {
    return value[0] === "-" ? value.slice(1) : "-" + value;
  }
}
function flipShadow(value) {
  const defs = splitByDivisor(value);
  const builtDefs = [];
  for (const def of defs) {
    const parts = def.split(" ");
    const index = _postcssValueParser.default.unit(parts[0]) === false ? 1 : 0;
    if (index < parts.length) {
      parts[index] = flipSign(parts[index]);
    }
    builtDefs.push(parts.join(" "));
  }
  const rtl = builtDefs.join(", ");
  if (rtl !== value) {
    return rtl;
  }
}
const shadowsFlip = {
  "box-shadow": _ref => {
    let [key, val] = _ref;
    const rtlVal = flipShadow(val);
    return rtlVal ? [key, rtlVal] : null;
  },
  "text-shadow": _ref2 => {
    let [key, val] = _ref2;
    const rtlVal = flipShadow(val);
    return rtlVal ? [key, rtlVal] : null;
  }
};
const logicalToPhysical = {
  start: "right",
  end: "left"
};
const propertyToRTL = {
  "margin-start": _ref3 => {
    let [_key, val] = _ref3;
    return ["margin-right", val];
  },
  "margin-end": _ref4 => {
    let [_key, val] = _ref4;
    return ["margin-left", val];
  },
  "padding-start": _ref5 => {
    let [_key, val] = _ref5;
    return ["padding-right", val];
  },
  "padding-end": _ref6 => {
    let [_key, val] = _ref6;
    return ["padding-left", val];
  },
  "border-start": _ref7 => {
    let [_key, val] = _ref7;
    return ["border-right", val];
  },
  "border-end": _ref8 => {
    let [_key, val] = _ref8;
    return ["border-left", val];
  },
  "border-start-width": _ref9 => {
    let [_key, val] = _ref9;
    return ["border-right-width", val];
  },
  "border-end-width": _ref10 => {
    let [_key, val] = _ref10;
    return ["border-left-width", val];
  },
  "border-start-color": _ref11 => {
    let [_key, val] = _ref11;
    return ["border-right-color", val];
  },
  "border-end-color": _ref12 => {
    let [_key, val] = _ref12;
    return ["border-left-color", val];
  },
  "border-start-style": _ref13 => {
    let [_key, val] = _ref13;
    return ["border-right-style", val];
  },
  "border-end-style": _ref14 => {
    let [_key, val] = _ref14;
    return ["border-left-style", val];
  },
  "border-top-start-radius": _ref15 => {
    let [_key, val] = _ref15;
    return ["border-top-right-radius", val];
  },
  "border-bottom-start-radius": _ref16 => {
    let [_key, val] = _ref16;
    return ["border-bottom-right-radius", val];
  },
  "border-top-end-radius": _ref17 => {
    let [_key, val] = _ref17;
    return ["border-top-left-radius", val];
  },
  "border-bottom-end-radius": _ref18 => {
    let [_key, val] = _ref18;
    return ["border-bottom-left-radius", val];
  },
  "text-align": _ref19 => {
    let [key, val] = _ref19;
    return logicalToPhysical[val] != null ? [key, logicalToPhysical[val]] : null;
  },
  float: _ref20 => {
    let [key, val] = _ref20;
    return logicalToPhysical[val] != null ? [key, logicalToPhysical[val]] : null;
  },
  clear: _ref21 => {
    let [key, val] = _ref21;
    return logicalToPhysical[val] != null ? [key, logicalToPhysical[val]] : null;
  },
  start: _ref22 => {
    let [_key, val] = _ref22;
    return ["right", val];
  },
  end: _ref23 => {
    let [_key, val] = _ref23;
    return ["left", val];
  },
  "background-position": _ref24 => {
    let [key, val] = _ref24;
    const words = val.split(" ");
    if (!words.includes("start") && !words.includes("end")) {
      return null;
    }
    return [key, words.map(word => word === "start" ? "right" : word === "end" ? "left" : word).join(" ")];
  },
  cursor: _ref25 => {
    let [key, val] = _ref25;
    return cursorFlip[val] != null ? [key, cursorFlip[val]] : null;
  },
  ...shadowsFlip
};
function generateRTL(_ref26) {
  let [key, value] = _ref26;
  if (propertyToRTL[key]) {
    return propertyToRTL[key]([key, value]);
  }
  return null;
}

var genCSSRule$1 = {};

Object.defineProperty(genCSSRule$1, "__esModule", {
  value: true
});
genCSSRule$1.genCSSRule = genCSSRule;
const THUMB_VARIANTS = ["::-webkit-slider-thumb", "::-moz-range-thumb", "::-ms-thumb"];
function genCSSRule(className, decls, pseudos, atRules) {
  const pseudo = pseudos.filter(p => p !== "::thumb").join("");
  let selectorForAtRules = `.${className}` + atRules.map(() => `.${className}`).join("") + pseudo;
  if (pseudos.includes("::thumb")) {
    selectorForAtRules = THUMB_VARIANTS.map(suffix => selectorForAtRules + suffix).join(", ");
  }
  return atRules.reduce((acc, atRule) => `${atRule}{${acc}}`, `${selectorForAtRules}{${decls}}`);
}

var propertyPriorities = {};

Object.defineProperty(propertyPriorities, "__esModule", {
  value: true
});
propertyPriorities.default = getPriority;
const PRIORITIES = {
  border: 1,
  "border-block-end": 2,
  "border-block-start": 2,
  "border-top": 2.1,
  "border-bottom": 2.1,
  "border-inline-end": 2,
  "border-inline-start": 2,
  "border-left": 2,
  "border-right": 2,
  grid: 2,
  "grid-area": 2,
  "border-color": 3,
  "border-style": 3,
  "border-width": 3,
  "border-image": 3,
  "border-radius": 3,
  animation: 3,
  background: 3,
  "column-rule": 3,
  columns: 3,
  flex: 3,
  "flex-flow": 3,
  font: 3,
  gap: 3,
  "grid-column": 3,
  "grid-row": 3,
  "grid-template": 3,
  "list-style": 3,
  margin: 3,
  mask: 3,
  offset: 3,
  outline: 3,
  overflow: 3,
  padding: 3,
  "place-content": 3,
  "place-items": 3,
  "place-self": 3,
  "scroll-margin": 3,
  "scroll-padding": 3,
  "text-decoration": 3,
  "text-emphasis": 3,
  transition: 3,
  ":has": 4.5,
  ":dir": 5,
  ":lang": 5.1,
  ":first-child": 5.2,
  ":last-child": 5.3,
  ":only-child": 5.4,
  ":nth-child": 6,
  ":nth-of-type": 6.1,
  ":only-of-type": 6.2,
  ":empty": 7,
  ":link": 8,
  ":any-link": 8.1,
  ":target": 8.2,
  ":visited": 8.3,
  ":enabled": 9.1,
  ":disabled": 9.2,
  ":required": 9.3,
  ":optional": 9.4,
  ":read-only": 9.5,
  ":read-write": 9.6,
  ":placeholder-shown": 9.7,
  ":default": 10,
  ":checked": 10.1,
  ":indeterminate": 10.1,
  ":blank": 10.2,
  ":valid": 10.3,
  ":invalid": 10.4,
  ":autofill": 11,
  ":picture-in-picture": 12,
  ":fullscreen": 12.1,
  ":paused": 12.2,
  ":playing": 12.3,
  ":hover": 13,
  ":focusWithin": 14,
  ":focusVisible": 15,
  ":focus": 16,
  ":active": 17
};
function getPriority(key) {
  if (key.startsWith("@supports")) {
    return 20;
  }
  if (key.startsWith("@media")) {
    return 21;
  }
  const prop = key.startsWith(":") && key.includes("(") ? key.slice(0, key.indexOf("(")) : key;
  let priority = PRIORITIES[prop] ?? 4;
  if (key.toLowerCase().includes("left") || key.toLowerCase().includes("right")) {
    priority += 0.1;
  }
  return priority;
}

Object.defineProperty(generateCssRule, "__esModule", {
  value: true
});
generateCssRule.generateRule = generateRule;
var _generateLtr$1 = _interopRequireDefault$8(generateLtr);
var _generateRtl$1 = _interopRequireDefault$8(generateRtl);
var _genCSSRule = genCSSRule$1;
var _propertyPriorities = _interopRequireDefault$8(propertyPriorities);
function _interopRequireDefault$8(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function generateRule(className, key, value, pseudos, atRules) {
  const pairs = Array.isArray(value) ? value.map(eachValue => [key, eachValue]) : [[key, value]];
  const ltrPairs = pairs.map(_generateLtr$1.default);
  const ltrDecls = ltrPairs.map(pair => pair.join(":")).join(";");
  const rtlDecls = pairs.map(_generateRtl$1.default).filter(Boolean).map(pair => pair.join(":")).join(";");
  const ltrRule = (0, _genCSSRule.genCSSRule)(className, ltrDecls, pseudos, atRules);
  const rtlRule = !rtlDecls ? null : (0, _genCSSRule.genCSSRule)(className, rtlDecls, pseudos, atRules);
  const priority = (0, _propertyPriorities.default)(key) + Math.max(...pseudos.map(_propertyPriorities.default), ...atRules.map(_propertyPriorities.default), 0);
  return {
    priority,
    ltr: ltrRule,
    rtl: rtlRule
  };
}

Object.defineProperty(convertToClassName, "__esModule", {
  value: true
});
convertToClassName.convertStyleToClassName = convertStyleToClassName;
var _hash$4 = _interopRequireDefault$7(hash$1);
var _dashify$1 = _interopRequireDefault$7(dashify$1);
var _transformValue$1 = _interopRequireDefault$7(transformValue$1);
var _generateCssRule = generateCssRule;
var _defaultOptions$4 = defaultOptions$1;
var _objectUtils$5 = objectUtils;
function _interopRequireDefault$7(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function convertStyleToClassName(objEntry, pseudos, atRules) {
  let {
    stylexSheetName = "<>",
    classNamePrefix = "x"
  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _defaultOptions$4.defaultOptions;
  const [key, rawValue] = objEntry;
  const dashedKey = (0, _dashify$1.default)(key);
  const value = Array.isArray(rawValue) ? rawValue.map(eachValue => (0, _transformValue$1.default)(key, eachValue)) : (0, _transformValue$1.default)(key, rawValue);
  const sortedPseudos = (0, _objectUtils$5.arraySort)(pseudos ?? []);
  const sortedAtRules = (0, _objectUtils$5.arraySort)(atRules ?? []);
  const atRuleHashString = sortedPseudos.join("");
  const pseudoHashString = sortedAtRules.join("");
  const modifierHashString = atRuleHashString + pseudoHashString || "null";
  const stringToHash = Array.isArray(value) ? dashedKey + value.join(", ") + modifierHashString : dashedKey + value + modifierHashString;
  const className = classNamePrefix + (0, _hash$4.default)(stylexSheetName + stringToHash);
  const cssRules = (0, _generateCssRule.generateRule)(className, dashedKey, value, pseudos, atRules);
  return [key, className, cssRules];
}

Object.defineProperty(PreRule$1, "__esModule", {
  value: true
});
PreRule$1.PreRuleSet = PreRule$1.PreRule = PreRule$1.PreIncludedStylesRule = PreRule$1.NullPreRule = void 0;
var _convertToClassName = convertToClassName;
var _objectUtils$4 = objectUtils;
class NullPreRule {
  compiled(_options) {
    return [null];
  }
  equals(other) {
    return other instanceof NullPreRule;
  }
}
PreRule$1.NullPreRule = NullPreRule;
class PreIncludedStylesRule {
  constructor(IncludedStyles) {
    this.includedStyles = IncludedStyles;
  }
  equals(other) {
    return other instanceof PreIncludedStylesRule && this.includedStyles === other.includedStyles;
  }
  compiled(_options) {
    return this.includedStyles;
  }
}
PreRule$1.PreIncludedStylesRule = PreIncludedStylesRule;
const stringComparator = (a, b) => {
  if (a === "default") {
    return -1;
  }
  if (b === "default") {
    return 1;
  }
  return a.localeCompare(b);
};
class PreRule {
  constructor(property, value, pseudos, atRules) {
    this.property = property;
    this.value = value;
    this.pseudos = pseudos ? (0, _objectUtils$4.arraySort)(pseudos, stringComparator) : [];
    this.atRules = atRules ? (0, _objectUtils$4.arraySort)(atRules) : [];
  }
  compiled(options) {
    const [_key, className, rule] = (0, _convertToClassName.convertStyleToClassName)([this.property, this.value], this.pseudos ?? [], this.atRules ?? [], options);
    return [[className, rule]];
  }
  equals(other) {
    if (!(other instanceof PreRule)) {
      return false;
    }
    const valuesEqual = Array.isArray(this.value) && Array.isArray(other.value) ? (0, _objectUtils$4.arrayEquals)(this.value, other.value) : this.value === other.value;
    return this.property === other.property && valuesEqual && (0, _objectUtils$4.arrayEquals)(this.pseudos, other.pseudos) && (0, _objectUtils$4.arrayEquals)(this.atRules, other.atRules);
  }
}
PreRule$1.PreRule = PreRule;
class PreRuleSet {
  constructor(rules) {
    this.rules = rules;
  }
  static create(rules) {
    const flatRules = rules.flatMap(rule => rule instanceof PreRuleSet ? rule.rules : [rule]);
    if (flatRules.length === 0) {
      return new NullPreRule();
    }
    if (flatRules.length === 1) {
      return flatRules[0];
    }
    return new PreRuleSet(flatRules);
  }
  compiled(options) {
    const styleTuple = this.rules.flatMap(rule => rule.compiled(options)).filter(Boolean);
    return styleTuple.length > 0 ? styleTuple : [null];
  }
  equals(other) {
    if (!(other instanceof PreRuleSet)) {
      return false;
    }
    if (this.rules.length !== other.rules.length) {
      return false;
    }
    return (0, _objectUtils$4.arrayEquals)(this.rules, other.rules, (a, b) => a.equals(b));
  }
}
PreRule$1.PreRuleSet = PreRuleSet;

Object.defineProperty(flattenRawStyleObj, "__esModule", {
  value: true
});
flattenRawStyleObj._flattenRawStyleObject = _flattenRawStyleObject;
flattenRawStyleObj.flattenRawStyleObject = flattenRawStyleObject;
var _index$1 = _interopRequireDefault$6(preprocessRules);
var _PreRule = PreRule$1;
var _stylexInclude$3 = stylexInclude$1;
function _interopRequireDefault$6(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function flattenRawStyleObject(style, options) {
  return _flattenRawStyleObject(style, [], [], options);
}
function _flattenRawStyleObject(style, pseudos, atRules, options) {
  const flattened = [];
  for (const key in style) {
    const value = style[key];
    if (typeof value === "object" && value instanceof _stylexInclude$3.IncludedStyles) {
      flattened.push([key, new _PreRule.PreIncludedStylesRule(value)]);
      continue;
    }
    if (value === null || typeof value === "string" || typeof value === "number") {
      const pairs = (0, _index$1.default)([key, value], options);
      for (const [property, value] of pairs) {
        if (value === null) {
          flattened.push([property, new _PreRule.NullPreRule()]);
        } else {
          flattened.push([property, new _PreRule.PreRule(property, value, pseudos, atRules)]);
        }
      }
      continue;
    }
    if (Array.isArray(value)) {
      const equivalentPairs = {};
      for (const eachVal of value) {
        const pairs = (0, _index$1.default)([key, eachVal], options);
        for (const [property, val] of pairs) {
          if (Array.isArray(val)) {
            if (equivalentPairs[property] == null) {
              equivalentPairs[property] = [...val];
            } else {
              equivalentPairs[property].push(...val);
            }
          } else if (equivalentPairs[property] == null) {
            equivalentPairs[property] = [val];
          } else {
            equivalentPairs[property].push(val);
          }
        }
      }
      Object.entries(equivalentPairs).map(_ref => {
        let [property, values] = _ref;
        return [property, [...new Set(values.filter(Boolean))]];
      }).map(_ref2 => {
        let [property, values] = _ref2;
        return [property, values.length === 0 ? null : values.length === 1 ? values[0] : values];
      }).forEach(_ref3 => {
        let [property, value] = _ref3;
        if (value === null) {
          flattened.push([property, new _PreRule.NullPreRule()]);
        } else {
          flattened.push([property, new _PreRule.PreRule(property, value, pseudos, atRules)]);
        }
      });
      continue;
    }
    if (typeof value === "object" && !key.startsWith(":") && !key.startsWith("@")) {
      const equivalentPairs = {};
      for (const condition in value) {
        const innerValue = value[condition];
        const pseudosToPassDown = [...pseudos];
        const atRulesToPassDown = [...atRules];
        if (condition.startsWith(":")) {
          pseudosToPassDown.push(condition);
        } else if (condition.startsWith("@")) {
          atRulesToPassDown.push(condition);
        }
        const pairs = _flattenRawStyleObject({
          [key]: innerValue
        }, pseudosToPassDown, atRulesToPassDown, options);
        for (const [property, preRule] of pairs) {
          if (preRule instanceof _PreRule.PreIncludedStylesRule) {
            throw new Error("stylex.include can only be used at the top-level");
          }
          if (equivalentPairs[property] == null) {
            equivalentPairs[property] = {
              [condition]: preRule
            };
          } else {
            equivalentPairs[property][condition] = preRule;
          }
        }
      }
      for (const [property, obj] of Object.entries(equivalentPairs)) {
        const sortedKeys = Object.keys(obj);
        const rules = [];
        for (const condition of sortedKeys) {
          rules.push(obj[condition]);
        }
        flattened.push([property, _PreRule.PreRuleSet.create(rules)]);
      }
    }
    if (typeof value === "object" && (key.startsWith(":") || key.startsWith("@"))) {
      const pseudosToPassDown = [...pseudos];
      const atRulesToPassDown = [...atRules];
      if (key.startsWith(":")) {
        pseudosToPassDown.push(key);
      } else if (key.startsWith("@")) {
        atRulesToPassDown.push(key);
      }
      const pairs = _flattenRawStyleObject(value, pseudosToPassDown, atRulesToPassDown, options);
      for (const [property, preRule] of pairs) {
        flattened.push([key + "_" + property, preRule]);
      }
    }
  }
  return flattened;
}

var basicValidation = {};

Object.defineProperty(basicValidation, "__esModule", {
  value: true
});
basicValidation.validateNamespace = validateNamespace;
var _stylexInclude$2 = stylexInclude$1;
var messages$1 = _interopRequireWildcard$1(messages$4);
var _objectUtils$3 = objectUtils;
function _getRequireWildcardCache$1(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache$1 = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard$1(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache$1(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function validateNamespace(namespace) {
  let conditions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  if (!(0, _objectUtils$3.isPlainObject)(namespace)) {
    throw new Error(messages$1.ILLEGAL_NAMESPACE_VALUE);
  }
  const ns = namespace;
  for (const key in ns) {
    const val = ns[key];
    if (val === null || typeof val === "string" || typeof val === "number") {
      continue;
    }
    if (Array.isArray(val)) {
      for (const v of val) {
        if (v === null || typeof v === "string" || typeof v === "number") {
          continue;
        }
        throw new Error(messages$1.ILLEGAL_PROP_ARRAY_VALUE);
      }
      continue;
    }
    if (val instanceof _stylexInclude$2.IncludedStyles) {
      if (conditions.length === 0) {
        continue;
      }
      throw new Error(messages$1.ONLY_TOP_LEVEL_INLCUDES);
    }
    if ((0, _objectUtils$3.isPlainObject)(val)) {
      if (key.startsWith("@") || key.startsWith(":")) {
        if (conditions.includes(key)) {
          throw new Error(messages$1.DUPLICATE_CONDITIONAL);
        }
        validateNamespace(val, [...conditions, key]);
      } else {
        validateConditionalStyles(val);
      }
      continue;
    }
    throw new Error(messages$1.ILLEGAL_PROP_VALUE);
  }
}
function validateConditionalStyles(val) {
  let conditions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  for (const key in val) {
    const v = val[key];
    if (!(key.startsWith("@") || key.startsWith(":") || key === "default")) {
      throw new Error(messages$1.INVALID_PSEUDO_OR_AT_RULE);
    }
    if (conditions.includes(key)) {
      throw new Error(messages$1.DUPLICATE_CONDITIONAL);
    }
    if (v === null || typeof v === "string" || typeof v === "number") {
      continue;
    }
    if (Array.isArray(v)) {
      for (const vv of v) {
        if (vv === null || typeof vv === "string" || typeof vv === "number") {
          continue;
        }
        throw new Error(messages$1.ILLEGAL_PROP_VALUE);
      }
      continue;
    }
    if (v instanceof _stylexInclude$2.IncludedStyles) {
      throw new Error(messages$1.ONLY_TOP_LEVEL_INLCUDES);
    }
    if ((0, _objectUtils$3.isPlainObject)(v)) {
      validateConditionalStyles(v, [...conditions, key]);
      continue;
    }
    throw new Error(messages$1.ILLEGAL_PROP_VALUE);
  }
}

Object.defineProperty(stylexCreate$1, "__esModule", {
  value: true
});
stylexCreate$1.default = styleXCreateSet;
var _objectUtils$2 = objectUtils;
var _stylexInclude$1 = stylexInclude$1;
var _defaultOptions$3 = defaultOptions$1;
var _flattenRawStyleObj = flattenRawStyleObj;
var _basicValidation = basicValidation;
function styleXCreateSet(namespaces) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultOptions$3.defaultOptions;
  const resolvedNamespaces = {};
  const injectedStyles = {};
  for (const namespaceName of Object.keys(namespaces)) {
    const namespace = namespaces[namespaceName];
    (0, _basicValidation.validateNamespace)(namespace);
    const flattenedNamespace = (0, _flattenRawStyleObj.flattenRawStyleObject)(namespace, options);
    const compiledNamespaceTuples = flattenedNamespace.map(_ref => {
      let [key, value] = _ref;
      return [key, value.compiled(options)];
    });
    const compiledNamespace = (0, _objectUtils$2.objFromEntries)(compiledNamespaceTuples);
    const namespaceObj = {};
    for (const key of Object.keys(compiledNamespace)) {
      const value = compiledNamespace[key];
      if (value instanceof _stylexInclude$1.IncludedStyles) {
        namespaceObj[key] = value;
      } else {
        const classNameTuples = value.map(v => Array.isArray(v) ? v : null).filter(Boolean);
        const className = classNameTuples.map(_ref2 => {
          let [className] = _ref2;
          return className;
        }).join(" ") || null;
        namespaceObj[key] = className;
        for (const [className, injectable] of classNameTuples) {
          if (injectedStyles[className] == null) {
            injectedStyles[className] = injectable;
          }
        }
      }
    }
    resolvedNamespaces[namespaceName] = {
      ...namespaceObj,
      $$css: true
    };
  }
  return [resolvedNamespaces, injectedStyles];
}

var stylexCreateVars$1 = {};

Object.defineProperty(stylexCreateVars$1, "__esModule", {
  value: true
});
stylexCreateVars$1.default = styleXCreateVars;
var _hash$3 = _interopRequireDefault$5(hash$1);
var _objectUtils$1 = objectUtils;
var _defaultOptions$2 = defaultOptions$1;
function _interopRequireDefault$5(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function styleXCreateVars(variables, options) {
  const {
    classNamePrefix,
    themeName
  } = {
    ..._defaultOptions$2.defaultOptions,
    ...options
  };
  const themeNameHash = classNamePrefix + (0, _hash$3.default)(themeName);
  const variablesMap = (0, _objectUtils$1.objMap)(variables, (value, key) => {
    const nameHash = classNamePrefix + (0, _hash$3.default)(`${themeName}.${key}`);
    return {
      nameHash,
      value
    };
  });
  const themeVariablesObject = (0, _objectUtils$1.objMap)(variablesMap, _ref => {
    let {
      nameHash
    } = _ref;
    return `var(--${nameHash})`;
  });
  const cssVariablesString = constructCssVariablesString(variablesMap);
  return [{
    ...themeVariablesObject,
    __themeName__: themeNameHash
  }, {
    css: cssVariablesString
  }];
}
function constructCssVariablesString(variables) {
  const atRules = {};
  const varsString = (0, _objectUtils$1.objEntries)(variables).map(_ref2 => {
    let [key, {
      nameHash,
      value
    }] = _ref2;
    if (value !== null && typeof value === "object") {
      if (value.default === undefined) {
        throw new Error("Default value is not defined for " + key + " variable.");
      }
      const definedVarString = `--${nameHash}:${value.default};`;
      Object.keys(value).forEach(key => {
        if (key.startsWith("@")) {
          const definedVarStringForAtRule = `--${nameHash}:${value[key]};`;
          if (atRules[key] == null) {
            atRules[key] = [definedVarStringForAtRule];
          } else {
            atRules[key].push(definedVarStringForAtRule);
          }
        }
      });
      return definedVarString;
    }
    return `--${nameHash}:${value};`;
  }).join("");
  const atRulesString = (0, _objectUtils$1.objEntries)(atRules).map(_ref3 => {
    let [atRule, varsArr] = _ref3;
    return `${atRule}{:root{${varsArr.join("")}}}`;
  }).join("");
  return `:root{${varsString}}${atRulesString || ""}`;
}

var stylexOverrideVars$1 = {};

Object.defineProperty(stylexOverrideVars$1, "__esModule", {
  value: true
});
stylexOverrideVars$1.default = styleXOverrideVars;
var _hash$2 = _interopRequireDefault$4(hash$1);
var _defaultOptions$1 = defaultOptions$1;
function _interopRequireDefault$4(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function styleXOverrideVars(themeVars, variables, options) {
  if (typeof themeVars.__themeName__ !== "string") {
    throw new Error("Can only override variables theme created with stylex.unstable_createVars().");
  }
  const {
    classNamePrefix
  } = {
    ..._defaultOptions$1.defaultOptions,
    ...options
  };
  const sortedKeys = Object.keys(variables).sort();
  const atRules = {};
  const cssVariablesOverrideString = sortedKeys.map(key => {
    const varNameHash = themeVars[key].slice(4, -1);
    const value = variables[key];
    if (varNameHash != null && value !== null && typeof value === "object") {
      if (value.default === undefined) {
        throw new Error("Default value is not defined for " + key + " variable.");
      }
      const definedVarString = `${varNameHash}:${value.default};`;
      Object.keys(value).forEach(key => {
        if (key.startsWith("@")) {
          const definedVarStringForAtRule = `${varNameHash}:${value[key]};`;
          if (atRules[key] == null) {
            atRules[key] = [definedVarStringForAtRule];
          } else {
            atRules[key].push(definedVarStringForAtRule);
          }
        }
      });
      return definedVarString;
    }
    return varNameHash != null && typeof value !== "object" ? `${varNameHash}:${value};` : "";
  }).join("");
  const sortedAtRules = Object.keys(atRules).sort();
  const atRulesStringForHash = sortedAtRules.map(atRule => {
    return `${atRule}{${atRules[atRule].sort().join("")}}`;
  }).join("");
  const overrideClassName = classNamePrefix + (0, _hash$2.default)(cssVariablesOverrideString + atRulesStringForHash);
  const atRulesCss = sortedAtRules.map(atRule => {
    return `${atRule}{.${overrideClassName}{${atRules[atRule].join("")}}}`;
  }).join("");
  return [{
    $$css: true,
    [themeVars.__themeName__]: overrideClassName
  }, {
    [overrideClassName]: {
      ltr: `.${overrideClassName}{${cssVariablesOverrideString}}${atRulesCss}`,
      priority: 0.99,
      rtl: undefined
    }
  }];
}

var stylexKeyframes = {};

Object.defineProperty(stylexKeyframes, "__esModule", {
  value: true
});
stylexKeyframes.default = styleXKeyframes;
var _hash$1 = _interopRequireDefault$3(hash$1);
var _index = _interopRequireDefault$3(preprocessRules);
var _generateLtr = _interopRequireDefault$3(generateLtr);
var _generateRtl = _interopRequireDefault$3(generateRtl);
var _transformValue = _interopRequireDefault$3(transformValue$1);
var _dashify = _interopRequireDefault$3(dashify$1);
var _objectUtils = objectUtils;
var _defaultOptions = defaultOptions$1;
function _interopRequireDefault$3(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function styleXKeyframes(frames) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _defaultOptions.defaultOptions;
  const {
    stylexSheetName = "<>",
    classNamePrefix = "x"
  } = options;
  const expandedObject = (0, _objectUtils.objMap)(frames, frame => _objectUtils.Pipe.create(frame).pipe(frame => expandFrameShorthands(frame, options)).pipe(x => (0, _objectUtils.objMapKeys)(x, _dashify.default)).pipe(x => (0, _objectUtils.objMap)(x, (value, key) => (0, _transformValue.default)(key, value))).done());
  const ltrStyles = (0, _objectUtils.objMap)(expandedObject, frame => (0, _objectUtils.objMapEntry)(frame, _generateLtr.default));
  const rtlStyles = (0, _objectUtils.objMap)(expandedObject, frame => (0, _objectUtils.objMapEntry)(frame, entry => (0, _generateRtl.default)(entry) ?? entry));
  const ltrString = constructKeyframesObj(ltrStyles);
  const rtlString = constructKeyframesObj(rtlStyles);
  const animationName = classNamePrefix + (0, _hash$1.default)(stylexSheetName + ltrString) + "-B";
  const ltr = `@keyframes ${animationName}{${ltrString}}`;
  const rtl = ltrString === rtlString ? null : `@keyframes ${animationName}{${rtlString}}`;
  return [animationName, {
    ltr,
    rtl,
    priority: 1
  }];
}
function expandFrameShorthands(frame, options) {
  return (0, _objectUtils.objFromEntries)((0, _objectUtils.objEntries)(frame).flatMap(pair => (0, _index.default)(pair, options).map(_ref => {
    let [key, value] = _ref;
    if (typeof value === "string" || typeof value === "number") {
      return [key, value];
    }
    return null;
  }).filter(Boolean)).filter(_ref2 => {
    let [_key, value] = _ref2;
    return value != null;
  }));
}
function constructKeyframesObj(frames) {
  return (0, _objectUtils.objEntries)(frames).map(_ref3 => {
    let [key, value] = _ref3;
    return `${key}{${(0, _objectUtils.objEntries)(value).map(_ref4 => {
      let [k, v] = _ref4;
      return `${k}:${v};`;
    }).join("")}}`;
  }).join("");
}

var stylexFirstThatWorks$1 = {};

Object.defineProperty(stylexFirstThatWorks$1, "__esModule", {
  value: true
});
stylexFirstThatWorks$1.default = stylexFirstThatWorks;
function stylexFirstThatWorks() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return [...args].reverse();
}

var fileBasedIdentifier = {};

Object.defineProperty(fileBasedIdentifier, "__esModule", {
  value: true
});
fileBasedIdentifier.default = genFileBasedIdentifier;
function genFileBasedIdentifier(_ref) {
  let {
    fileName,
    exportName,
    key
  } = _ref;
  return `${fileName}//${exportName}${key != null ? `.${key}` : ""}`;
}

var types$1 = {};

Object.defineProperty(types$1, "__esModule", {
  value: true
});
types$1.url = types$1.transformList = types$1.transformFunction = types$1.time = types$1.resolution = types$1.percentage = types$1.number = types$1.lengthPercentage = types$1.length = types$1.integer = types$1.image = types$1.color = types$1.angle = types$1.Url = types$1.TransformList = types$1.TransformFunction = types$1.Time = types$1.Resolution = types$1.Percentage = types$1.Num = types$1.LengthPercentage = types$1.Length = types$1.Integer = types$1.Image = types$1.Color = types$1.CSSType = types$1.Angle = void 0;
class CSSType {}
types$1.CSSType = CSSType;
class Angle extends CSSType {
  syntax = "<angle>";
  static syntax = "<angle>";
  constructor(value) {
    super();
    this.value = value;
  }
  static create(value) {
    return new Angle(value);
  }
}
types$1.Angle = Angle;
const angle = Angle.create;
types$1.angle = angle;
class Color extends CSSType {
  syntax = "<color>";
  constructor(value) {
    super();
    this.value = value;
  }
  static create(value) {
    return new Color(value);
  }
}
types$1.Color = Color;
const color = Color.create;
types$1.color = color;
class Url extends CSSType {
  syntax = "<url>";
  constructor(value) {
    super();
    this.value = value;
  }
  static create(value) {
    return new Url(value);
  }
}
types$1.Url = Url;
const url = Url.create;
types$1.url = url;
class Image extends Url {
  syntax = "<image>";
  constructor(value) {
    super(value);
    this.value = value;
  }
  static create(value) {
    return new Image(value);
  }
}
types$1.Image = Image;
const image = Image.create;
types$1.image = image;
class Integer extends CSSType {
  syntax = "<integer>";
  constructor(value) {
    super();
    this.value = value;
  }
  static create(value) {
    return new Integer(value);
  }
}
types$1.Integer = Integer;
const integer = Integer.create;
types$1.integer = integer;
class LengthPercentage extends CSSType {
  syntax = "<length-percentage>";
  constructor(value) {
    super();
    this.value = value;
  }
  static createLength(value) {
    return new LengthPercentage(convertNumberToLength(value));
  }
  static createPercentage(value) {
    return new LengthPercentage(convertNumberToPercentage(value));
  }
}
types$1.LengthPercentage = LengthPercentage;
const lengthPercentage = LengthPercentage.createLength;
types$1.lengthPercentage = lengthPercentage;
class Length extends LengthPercentage {
  syntax = "<length>";
  constructor(value) {
    super(convertNumberToLength(value));
  }
  static create(value) {
    return new Length(value);
  }
}
types$1.Length = Length;
const length = Length.create;
types$1.length = length;
class Percentage extends LengthPercentage {
  syntax = "<percentage>";
  constructor(value) {
    super(convertNumberToPercentage(value));
  }
  static create(value) {
    return new Percentage(value);
  }
}
types$1.Percentage = Percentage;
const percentage = Percentage.create;
types$1.percentage = percentage;
class Num extends CSSType {
  syntax = "<number>";
  constructor(value) {
    super();
    this.value = value;
  }
  static create(value) {
    return new Num(value);
  }
}
types$1.Num = Num;
const number = Num.create;
types$1.number = number;
class Resolution extends CSSType {
  syntax = "<resolution>";
  constructor(value) {
    super();
    this.value = value;
  }
  static create(value) {
    return new Resolution(value);
  }
}
types$1.Resolution = Resolution;
const resolution = Resolution.create;
types$1.resolution = resolution;
class Time extends CSSType {
  syntax = "<time>";
  constructor(value) {
    super();
    this.value = value;
  }
  static create(value) {
    return new Time(value);
  }
}
types$1.Time = Time;
const time = Time.create;
types$1.time = time;
class TransformFunction extends CSSType {
  syntax = "<transform-function>";
  constructor(value) {
    super();
    this.value = value;
  }
  static create(value) {
    return new TransformFunction(value);
  }
}
types$1.TransformFunction = TransformFunction;
const transformFunction = TransformFunction.create;
types$1.transformFunction = transformFunction;
class TransformList extends CSSType {
  syntax = "<transform-list>";
  constructor(value) {
    super();
    this.value = value;
  }
  static create(value) {
    return new TransformList(value);
  }
}
types$1.TransformList = TransformList;
const transformList = TransformList.create;
types$1.transformList = transformList;
const convertNumberToStringUsing = (transformNumber, defaultStr) => value => {
  if (typeof value === "number") {
    return transformNumber(value);
  }
  if (typeof value === "string") {
    return value;
  }
  if (typeof value === "object") {
    const {
      default: defaultValue,
      ...rest
    } = value;
    const defaultResult = convertNumberToLength(defaultValue);
    const result = {
      default: typeof defaultResult === "string" ? defaultResult : defaultStr
    };
    for (const [key, value] of Object.entries(rest)) {
      result[key] = convertNumberToLength(value);
    }
    return result;
  }
  return value;
};
const convertNumberToLength = convertNumberToStringUsing(value => value === 0 ? "0" : `${value}px`, "0px");
const convertNumberToPercentage = convertNumberToStringUsing(value => value === 0 ? "0" : `${value * 100}%`, "0");

Object.defineProperty(lib, "__esModule", {
  value: true
});
var utils_1 = lib.utils = lib.types = overrideVars_1 = lib.overrideVars = messages_1 = lib.messages = keyframes_1 = lib.keyframes = include_1 = lib.include = firstThatWorks_1 = lib.firstThatWorks = createVars_1 = lib.createVars = create_1 = lib.create = IncludedStyles_1 = lib.IncludedStyles = void 0;
var _stylexCreate = _interopRequireDefault$2(stylexCreate$1);
var _stylexCreateVars = _interopRequireDefault$2(stylexCreateVars$1);
var _stylexOverrideVars = _interopRequireDefault$2(stylexOverrideVars$1);
var _stylexKeyframes = _interopRequireDefault$2(stylexKeyframes);
var _stylexInclude = _interopRequireWildcard(stylexInclude$1);
var _stylexFirstThatWorks = _interopRequireDefault$2(stylexFirstThatWorks$1);
var _hash = _interopRequireDefault$2(hash$1);
var _fileBasedIdentifier = _interopRequireDefault$2(fileBasedIdentifier);
var m = _interopRequireWildcard(messages$4);
var _types = _interopRequireWildcard(types$1);
lib.types = _types;
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault$2(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const create$1 = _stylexCreate.default;
var create_1 = lib.create = create$1;
const createVars = _stylexCreateVars.default;
var createVars_1 = lib.createVars = createVars;
const overrideVars = _stylexOverrideVars.default;
var overrideVars_1 = lib.overrideVars = overrideVars;
const keyframes$1 = _stylexKeyframes.default;
var keyframes_1 = lib.keyframes = keyframes$1;
const include$1 = _stylexInclude.default;
var include_1 = lib.include = include$1;
const utils = {
  hash: _hash.default,
  genFileBasedIdentifier: _fileBasedIdentifier.default
};
utils_1 = lib.utils = utils;
const messages = m;
var messages_1 = lib.messages = messages;
const IncludedStyles = _stylexInclude.IncludedStyles;
var IncludedStyles_1 = lib.IncludedStyles = IncludedStyles;
const firstThatWorks$1 = _stylexFirstThatWorks.default;
var firstThatWorks_1 = lib.firstThatWorks = firstThatWorks$1;

function namespaceToDevClassName(namespace, varName, filename) {
  const basename = path.basename(filename).split(".")[0];
  const className = `${basename}__${varName ? `${varName}.` : ""}${namespace}`;
  return className.replace(/[^.a-zA-Z0-9_-]/g, "");
}
function injectDevClassNames(obj, varName, state) {
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    const devClassName = namespaceToDevClassName(key, varName, state.filename ?? "UnkownFile");
    result[key] = {
      [devClassName]: devClassName,
      ...value
    };
  }
  return result;
}
function convertToTestStyles(obj, varName, state) {
  const result = {};
  for (const [key, _value] of Object.entries(obj)) {
    const devClassName = namespaceToDevClassName(key, varName, state.filename ?? "UnkownFile");
    result[key] = {
      [devClassName]: devClassName,
      $$css: true
    };
  }
  return result;
}

function convertObjectToAST(obj) {
  return t__namespace.objectExpression(Object.entries(obj).map(_ref => {
    let [key, value] = _ref;
    return value instanceof IncludedStyles_1 ? t__namespace.spreadElement(value.astNode) : t__namespace.objectProperty(canBeIdentifier(key) ? t__namespace.identifier(key) : t__namespace.stringLiteral(key), typeof value === "string" ? t__namespace.stringLiteral(value) : typeof value === "boolean" ? t__namespace.booleanLiteral(value) : value === null ? t__namespace.nullLiteral() : convertObjectToAST(value));
  }));
}
function canBeIdentifier(str) {
  return str.match(/^[a-zA-Z_$][a-zA-Z0-9_$]*$/) != null;
}

function isArrayExpression(path, props) {
  return path.isArrayExpression(props);
}
function isArrowFunctionExpression(path, props) {
  return path.isArrowFunctionExpression(props);
}
function isBinaryExpression(path, props) {
  return path.isBinaryExpression(props);
}
function isBooleanLiteral(path, props) {
  return path.isBooleanLiteral(props);
}
function isCallExpression(path, props) {
  return path.isCallExpression(props);
}
function isClass(path, props) {
  return path.isClass(props);
}
function isConditionalExpression(path, props) {
  return path.isConditionalExpression(props);
}
function isExportDefaultDeclaration(path, props) {
  return path.isExportDefaultDeclaration(props);
}
function isExportNamedDeclaration(path, props) {
  return path.isExportNamedDeclaration(props);
}
function isExpression(path, props) {
  return path.isExpression(props);
}
function isExpressionStatement(path, props) {
  return path.isExpressionStatement(props);
}
function isExpressionWrapper(path, props) {
  return path.isExpressionWrapper(props);
}
function isFunction(path, props) {
  return path.isFunction(props);
}
function isIdentifier(path, props) {
  return path.isIdentifier(props);
}
function isImportDeclaration(path, props) {
  return path.isImportDeclaration(props);
}
function isImportDefaultSpecifier(path, props) {
  return path.isImportDefaultSpecifier(props);
}
function isImportSpecifier(path, props) {
  return path.isImportSpecifier(props);
}
function isLogicalExpression(path, props) {
  return path.isLogicalExpression(props);
}
function isMemberExpression(path, props) {
  return path.isMemberExpression(props);
}
function isNullLiteral(path, props) {
  return path.isNullLiteral(props);
}
function isNumericLiteral(path, props) {
  return path.isNumericLiteral(props);
}
function isObjectExpression(path, props) {
  return path.isObjectExpression(props);
}
function isObjectMethod(path, props) {
  return path.isObjectMethod(props);
}
function isObjectProperty(path, props) {
  return path.isObjectProperty(props);
}
function isProgram(path, props) {
  return path.isProgram(props);
}
function isSequenceExpression(path, props) {
  return path.isSequenceExpression(props);
}
function isSpreadElement(path, props) {
  return path.isSpreadElement(props);
}
function isStatement(path, props) {
  return path.isStatement(props);
}
function isStringLiteral(path, props) {
  return path.isStringLiteral(props);
}
function isTaggedTemplateExpression(path, props) {
  return path.isTaggedTemplateExpression(props);
}
function isTemplateLiteral(path, props) {
  return path.isTemplateLiteral(props);
}
function isUnaryExpression(path, props) {
  return path.isUnaryExpression(props);
}
function isVariableDeclaration(path, props) {
  return path.isVariableDeclaration(props);
}
function isVariableDeclarator(path, props) {
  return path.isVariableDeclarator(props);
}
function isReferencedIdentifier(path, props) {
  return path.isReferencedIdentifier(props);
}

const VALID_CALLEES = ["String", "Number", "Math", "Object", "Array"];
const INVALID_METHODS = ["random", "assign", "defineProperties", "defineProperty", "freeze", "seal", "splice"];
function isValidCallee(val) {
  return VALID_CALLEES.includes(val);
}
function isInvalidMethod(val) {
  return INVALID_METHODS.includes(val);
}
function deopt(path, state) {
  if (!state.confident) return;
  state.deoptPath = path;
  state.confident = false;
}
function evaluateImportedFile(filePath, namedExport, state) {
  const fileContents = fs.readFileSync(filePath, "utf8");
  const ast = core.parseSync(fileContents, {
    babelrc: true
  });
  if (!ast || ast.errors || !t__namespace.isNode(ast)) {
    state.confident = false;
    return;
  }
  const astNode = ast;
  let result;
  traverse(astNode, {
    ExportNamedDeclaration(path) {
      const declaration = path.get("declaration");
      if (isVariableDeclaration(declaration)) {
        const decls = declaration.get("declarations");
        const finder = decl => {
          if (isVariableDeclarator(decl)) {
            const id = decl.get("id");
            const init = decl.get("init");
            if (isIdentifier(id) && id.node.name === namedExport && init != null && isExpression(init)) {
              result = evaluateCached(init, state);
            }
          }
        };
        if (Array.isArray(decls)) {
          decls.forEach(finder);
        } else {
          finder(decls);
        }
      }
    }
  });
  if (state.confident) {
    return result;
  } else {
    state.confident = false;
    return;
  }
}
function evaluateThemeRef(fileName, exportName, state) {
  const resolveKey = key => {
    const strToHash = key === "__themeName__" ? utils_1.genFileBasedIdentifier({
      fileName,
      exportName
    }) : utils_1.genFileBasedIdentifier({
      fileName,
      exportName,
      key
    });
    const varName = state.traversalState.options.classNamePrefix + utils_1.hash(strToHash);
    return `var(--${varName})`;
  };
  const proxy = new Proxy({}, {
    get(_, key) {
      return resolveKey(key);
    },
    set(_, key, value) {
      throw new Error(`Cannot set value ${value} to key ${key} in theme ${fileName}`);
    }
  });
  return proxy;
}
function evaluateCached(path, state) {
  const {
    node
  } = path;
  const {
    seen
  } = state;
  const existing = seen.get(node);
  if (existing != null) {
    if (existing.resolved) {
      return existing.value;
    } else {
      deopt(path, state);
      return;
    }
  } else {
    const item = {
      resolved: false
    };
    seen.set(node, item);
    const val = _evaluate(path, state);
    if (state.confident) {
      item.resolved = true;
      item.value = val;
    }
    return val;
  }
}
function _evaluate(path, state) {
  if (!state.confident) return;
  if (isArrowFunctionExpression(path)) {
    const body = path.get("body");
    const params = path.get("params");
    const identParams = params.filter(param => isIdentifier(param)).map(paramPath => paramPath.node.name);
    if (isExpression(body) && identParams.length === params.length) {
      const expr = body;
      return function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        const identifierEntries = identParams.map((ident, index) => [ident, args[index]]);
        const identifiersObj = Object.fromEntries(identifierEntries);
        const result = evaluate(expr, state.traversalState, {
          ...state.functions,
          identifiers: {
            ...state.functions.identifiers,
            ...identifiersObj
          }
        });
        return result.value;
      };
    }
  }
  if (isIdentifier(path)) {
    const name = path.node.name;
    if (Object.keys(state.functions?.identifiers ?? {}).includes(name)) {
      return state.functions.identifiers[name];
    }
  }
  if (isSequenceExpression(path)) {
    const exprs = path.get("expressions");
    return evaluateCached(exprs[exprs.length - 1], state);
  }
  if (isStringLiteral(path) || isNumericLiteral(path) || isBooleanLiteral(path)) {
    return path.node.value;
  }
  if (isNullLiteral(path)) {
    return null;
  }
  if (isTemplateLiteral(path)) {
    return evaluateQuasis(path, path.node.quasis, state);
  }
  const maybeTag = isTaggedTemplateExpression(path) && path.get("tag");
  if (isTaggedTemplateExpression(path) && maybeTag && isMemberExpression(maybeTag)) {
    const tag = maybeTag;
    const object = tag.get("object");
    if (isIdentifier(object)) {
      const name = object.node.name;
      const property = tag.get("property");
      if (name === "String" && !path.scope.hasBinding(name) && isIdentifier(property) && property.node.name === "raw") {
        return evaluateQuasis(path, path.node.quasi.quasis, state, true);
      }
    }
  }
  if (isConditionalExpression(path)) {
    const testResult = evaluateCached(path.get("test"), state);
    if (!state.confident) return;
    if (testResult) {
      return evaluateCached(path.get("consequent"), state);
    } else {
      return evaluateCached(path.get("alternate"), state);
    }
  }
  if (isExpressionWrapper(path)) {
    return evaluateCached(path.get("expression"), state);
  }
  if (isMemberExpression(path) && !isCallExpression(path.parentPath, {
    callee: path.node
  })) {
    const object = evaluateCached(path.get("object"), state);
    if (!state.confident) {
      return;
    }
    const propPath = path.get("property");
    let property;
    if (path.node.computed) {
      property = evaluateCached(propPath, state);
      if (!state.confident) {
        return;
      }
    } else if (isIdentifier(propPath)) {
      property = propPath.node.name;
    } else if (isStringLiteral(propPath)) {
      property = propPath.node.value;
    } else {
      return deopt(propPath, state);
    }
    return object[property];
  }
  if (isReferencedIdentifier(path)) {
    const binding = path.scope?.getBinding(path.node.name);
    const bindingPath = binding?.path;
    if (binding && bindingPath && !isImportDefaultSpecifier(bindingPath) && isImportSpecifier(bindingPath)) {
      const importSpecifierPath = bindingPath;
      const importSpecifierNode = importSpecifierPath.node;
      const imported = importSpecifierNode.imported;
      const importedName = imported.type === "Identifier" ? imported.name : imported.value;
      const importPath = binding.path.parentPath;
      if (importPath && isImportDeclaration(importPath)) {
        const absPath = state.traversalState.importPathResolver(importPath.node.source.value);
        if (!absPath) {
          return deopt(binding.path, state);
        }
        const [type, value] = absPath;
        const returnValue = type === "themeNameRef" ? evaluateThemeRef(value, importedName, state) : evaluateImportedFile(value, importedName, state);
        if (state.confident) {
          return returnValue;
        } else {
          deopt(binding.path, state);
        }
      }
    }
    if (binding && binding.constantViolations.length > 0) {
      return deopt(binding.path, state);
    }
    if (binding && path.node.start < binding.path.node.end) {
      return deopt(binding.path, state);
    }
    if (binding && binding.hasValue) {
      return binding.value;
    } else {
      if (path.node.name === "undefined") {
        return binding ? deopt(binding.path, state) : undefined;
      } else if (path.node.name === "Infinity") {
        return binding ? deopt(binding.path, state) : Infinity;
      } else if (path.node.name === "NaN") {
        return binding ? deopt(binding.path, state) : NaN;
      }
      const resolved = path.resolve();
      if (resolved === path) {
        return deopt(path, state);
      } else {
        return evaluateCached(resolved, state);
      }
    }
  }
  if (isUnaryExpression(path, {
    prefix: true
  })) {
    if (path.node.operator === "void") {
      return undefined;
    }
    const argument = path.get("argument");
    if (path.node.operator === "typeof" && (isFunction(argument) || isClass(argument))) {
      return "function";
    }
    const arg = evaluateCached(argument, state);
    if (!state.confident) return;
    switch (path.node.operator) {
      case "!":
        return !arg;
      case "+":
        return +arg;
      case "-":
        return -arg;
      case "~":
        return ~arg;
      case "typeof":
        return typeof arg;
      case "void":
        return undefined;
      default:
        return deopt(path, state);
    }
  }
  if (isArrayExpression(path)) {
    const arrPath = path;
    const arr = [];
    const elems = arrPath.get("elements");
    for (const elem of elems) {
      const elemValue = evaluate(elem, state.traversalState, state.functions);
      if (elemValue.confident) {
        arr.push(elemValue.value);
      } else {
        elemValue.deopt && deopt(elemValue.deopt, state);
        return;
      }
    }
    return arr;
  }
  if (isObjectExpression(path)) {
    const obj = {};
    const props = path.get("properties");
    for (const prop of props) {
      if (isObjectMethod(prop)) {
        return deopt(prop, state);
      }
      if (isSpreadElement(prop)) {
        const spreadExpression = evaluateCached(prop.get("argument"), state);
        if (!state.confident) {
          return deopt(prop, state);
        }
        Object.assign(obj, spreadExpression);
        continue;
      }
      if (isObjectProperty(prop)) {
        const keyPath = prop.get("key");
        let key;
        if (prop.node.computed) {
          const {
            confident,
            deopt: resultDeopt,
            value
          } = evaluate(keyPath, state.traversalState, state.functions);
          if (!confident) {
            resultDeopt && deopt(resultDeopt, state);
            return;
          }
          key = value;
        } else if (isIdentifier(keyPath)) {
          key = keyPath.node.name;
        } else {
          key = keyPath.node.value;
        }
        const valuePath = prop.get("value");
        let value = evaluate(valuePath, state.traversalState, state.functions);
        if (!value.confident) {
          value.deopt && deopt(value.deopt, state);
          return;
        }
        value = value.value;
        obj[key] = value;
      }
    }
    return obj;
  }
  if (isLogicalExpression(path)) {
    const wasConfident = state.confident;
    const left = evaluateCached(path.get("left"), state);
    const leftConfident = state.confident;
    state.confident = wasConfident;
    const right = evaluateCached(path.get("right"), state);
    const rightConfident = state.confident;
    switch (path.node.operator) {
      case "||":
        state.confident = leftConfident && (!!left || rightConfident);
        if (!state.confident) return;
        return left || right;
      case "&&":
        state.confident = leftConfident && (!left || rightConfident);
        if (!state.confident) return;
        return left && right;
      case "??":
        state.confident = leftConfident && !!(left ?? rightConfident);
        if (!state.confident) return;
        return left ?? right;
      default:
        path.node.operator;
    }
  }
  if (isBinaryExpression(path)) {
    const left = evaluateCached(path.get("left"), state);
    if (!state.confident) return;
    const right = evaluateCached(path.get("right"), state);
    if (!state.confident) return;
    switch (path.node.operator) {
      case "-":
        return left - right;
      case "+":
        return left + right;
      case "/":
        return left / right;
      case "*":
        return left * right;
      case "%":
        return left % right;
      case "**":
        return left ** right;
      case "<":
        return left < right;
      case ">":
        return left > right;
      case "<=":
        return left <= right;
      case ">=":
        return left >= right;
      case "==":
        return left == right;
      case "!=":
        return left !== right;
      case "===":
        return left === right;
      case "!==":
        return left !== right;
      case "|":
        return left | right;
      case "&":
        return left & right;
      case "^":
        return left ^ right;
      case "<<":
        return left << right;
      case ">>":
        return left >> right;
      case ">>>":
        return left >>> right;
      case "in":
        return left in right;
      case "instanceof":
        return left instanceof right;
      default:
        return;
    }
  }
  if (isCallExpression(path)) {
    const callee = path.get("callee");
    let context;
    let func;
    if (isIdentifier(callee) && !path.scope.getBinding(callee.node.name) && isValidCallee(callee.node.name)) {
      func = global[callee.node.name];
    } else if (isIdentifier(callee) && state.functions.identifiers[callee.node.name]) {
      func = state.functions.identifiers[callee.node.name];
    }
    if (isMemberExpression(callee)) {
      const object = callee.get("object");
      const property = callee.get("property");
      if (isIdentifier(object) && isIdentifier(property)) {
        if (isValidCallee(object.node.name) && !isInvalidMethod(property.node.name)) {
          context = global[object.node.name];
          func = context[property.node.name];
        } else if (state.functions.memberExpressions[object.node.name] && state.functions.memberExpressions[object.node.name][property.node.name]) {
          context = state.functions.memberExpressions[object.node.name];
          func = context[property.node.name];
        }
      }
      if (isIdentifier(object) && isStringLiteral(property) && state.functions.memberExpressions[object.node.name] && state.functions.memberExpressions[object.node.name][property.node.value]) {
        context = state.functions.memberExpressions[object.node.name];
        func = context[property.node.value];
      }
      if ((isStringLiteral(object) || isNumericLiteral(object)) && isIdentifier(property)) {
        const val = object.node.value;
        func = val[property.node.name];
      }
      const parsedObj = evaluate(object, state.traversalState, state.functions);
      if (parsedObj.confident && isIdentifier(property)) {
        func = parsedObj.value[property.node.name];
        context = parsedObj.value;
      }
      if (parsedObj.confident && isStringLiteral(property)) {
        func = parsedObj.value[property.node.value];
        context = parsedObj.value;
      }
    }
    if (func) {
      if (func.takesPath) {
        const args = path.get("arguments");
        return func.fn(...args);
      } else {
        const args = path.get("arguments").map(arg => evaluateCached(arg, state));
        if (!state.confident) return;
        if (func.fn) {
          return func.fn.apply(context, args);
        } else {
          return func.apply(context, args);
        }
      }
    }
  }
  deopt(path, state);
}
function evaluateQuasis(path, quasis, state) {
  let raw = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  let str = "";
  let i = 0;
  const exprs = isTemplateLiteral(path) ? path.get("expressions") : isTaggedTemplateExpression(path) ? path.get("quasi").get("expressions") : [];
  for (const elem of quasis) {
    if (!state.confident) break;
    str += raw ? elem.value.raw : elem.value.cooked;
    const expr = exprs[i++];
    if (expr) str += String(evaluateCached(expr, state));
  }
  if (!state.confident) return;
  return str;
}
function evaluate(path, traversalState) {
  let functions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    identifiers: {},
    memberExpressions: {}
  };
  const state = {
    confident: true,
    deoptPath: null,
    seen: new Map(),
    functions,
    traversalState
  };
  let value = evaluateCached(path, state);
  if (!state.confident) value = undefined;
  return {
    confident: state.confident,
    deopt: state.deoptPath,
    value: value
  };
}

function evaluateStyleXCreateArg(path, traversalState) {
  let functions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    identifiers: {},
    memberExpressions: {}
  };
  if (!isObjectExpression(path)) {
    return evaluate(path, traversalState, functions);
  }
  const value = {};
  const fns = {};
  for (const prop of path.get("properties")) {
    if (!isObjectProperty(prop)) {
      return evaluate(path, traversalState, functions);
    }
    const objPropPath = prop;
    const keyResult = evaluateObjKey(objPropPath, traversalState, functions);
    if (!keyResult.confident) {
      return {
        confident: false,
        deopt: keyResult.deopt,
        value: null
      };
    }
    const key = keyResult.value;
    const valPath = prop.get("value");
    if (!isArrowFunctionExpression(valPath)) {
      const val = evaluate(valPath, traversalState, functions);
      if (!val.confident) {
        return val;
      }
      value[key] = val.value;
      continue;
    }
    const fnPath = valPath;
    const allParams = fnPath.get("params");
    const params = allParams.filter(param => isIdentifier(param)).map(param => param.node);
    if (params.length !== allParams.length) {
      return {
        confident: false,
        deopt: valPath,
        value: null
      };
    }
    const fnBody = fnPath.get("body");
    if (!isObjectExpression(fnBody)) {
      return evaluate(path, traversalState, functions);
    }
    const fnObjectBody = fnBody;
    const evalResult = evaluatePartialObjectRecursively(fnObjectBody, traversalState, functions);
    if (!evalResult.confident) {
      const {
        confident,
        value: v,
        deopt
      } = evalResult;
      return {
        confident,
        value: v,
        deopt
      };
    }
    const {
      value: v,
      inlineStyles
    } = evalResult;
    value[key] = v;
    fns[key] = [params, inlineStyles ?? {}];
  }
  return {
    value,
    confident: true,
    fns
  };
}
function evaluatePartialObjectRecursively(path, traversalState) {
  let functions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    identifiers: {},
    memberExpressions: {}
  };
  let keyPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  const obj = {};
  const inlineStyles = {};
  const props = path.get("properties");
  for (const prop of props) {
    if (isObjectMethod(prop)) {
      return {
        value: null,
        confident: false
      };
    }
    if (isSpreadElement(prop)) {
      const result = evaluate(prop.get("argument"), traversalState, functions);
      if (!result.confident) {
        return result;
      }
      Object.assign(obj, result.value);
      continue;
    }
    if (isObjectProperty(prop)) {
      const keyResult = evaluateObjKey(prop, traversalState, functions);
      if (!keyResult.confident) {
        return {
          confident: false,
          deopt: keyResult.deopt,
          value: null
        };
      }
      const key = keyResult.value;
      const valuePath = prop.get("value");
      if (isObjectExpression(valuePath)) {
        const result = evaluatePartialObjectRecursively(valuePath, traversalState, functions, [...keyPath, key]);
        if (!result.confident) {
          return {
            confident: false,
            deopt: result.deopt,
            value: null
          };
        }
        obj[key] = result.value;
        Object.assign(inlineStyles, result.inlineStyles);
      } else {
        const result = evaluate(valuePath, traversalState, functions);
        if (!result.confident) {
          const varName = "--" + (keyPath.length > 0 ? utils_1.hash([...keyPath, key].join("_")) : key);
          obj[key] = `var(${varName}, revert)`;
          const node = valuePath.node;
          if (!t__namespace.isExpression(node)) {
            throw new Error("Expected expression as style value");
          }
          const expression = node;
          const unit = timeUnits_1.has(key) || lengthUnits_1.has(key) ? getNumberSuffix_1(key) : "";
          inlineStyles[varName] = unit !== "" ? t__namespace.callExpression(t__namespace.arrowFunctionExpression([t__namespace.identifier("val")], t__namespace.conditionalExpression(t__namespace.binaryExpression("===", t__namespace.unaryExpression("typeof", t__namespace.identifier("val")), t__namespace.stringLiteral("number")), t__namespace.binaryExpression("+", t__namespace.identifier("val"), t__namespace.stringLiteral(unit)), t__namespace.logicalExpression("??", t__namespace.identifier("val"), t__namespace.stringLiteral("initial")))), [expression]) : t__namespace.logicalExpression("??", expression, t__namespace.stringLiteral("initial"));
        } else {
          obj[key] = result.value;
        }
      }
    }
  }
  return {
    value: obj,
    confident: true,
    inlineStyles
  };
}
function evaluateObjKey(prop, traversalState, functions) {
  const keyPath = prop.get("key");
  let key;
  if (prop.node.computed) {
    const result = evaluate(keyPath, traversalState, functions);
    if (!result.confident) {
      return {
        confident: false,
        deopt: result.deopt
      };
    }
    key = result.value;
  } else if (isIdentifier(keyPath)) {
    key = keyPath.node.name;
  } else {
    key = keyPath.node.value;
  }
  return {
    confident: true,
    value: String(key)
  };
}

function transformStyleXCreate(path, state) {
  const {
    node
  } = path;
  if (node.type !== "CallExpression") {
    return;
  }
  if (node.callee.type === "Identifier" && state.stylexCreateImport.has(node.callee.name) || node.callee.type === "MemberExpression" && node.callee.object.type === "Identifier" && node.callee.property.type === "Identifier" && node.callee.property.name === "create" && state.stylexImport.has(node.callee.object.name)) {
    validateStyleXCreate(path);
    const args = path.get("arguments");
    const firstArg = args[0];
    if (!isObjectExpression(firstArg)) {
      throw new Error(messages_1.ILLEGAL_ARGUMENT_LENGTH);
    }
    state.inStyleXCreate = true;
    const injectedKeyframes = {};
    function keyframes(animation) {
      const [animationName, injectedStyle] = keyframes_1(animation, state.options);
      injectedKeyframes[animationName] = injectedStyle;
      return animationName;
    }
    const identifiers = {};
    const memberExpressions = {};
    state.stylexIncludeImport.forEach(name => {
      identifiers[name] = {
        fn: include_1,
        takesPath: true
      };
    });
    state.stylexFirstThatWorksImport.forEach(name => {
      identifiers[name] = {
        fn: firstThatWorks_1
      };
    });
    state.stylexKeyframesImport.forEach(name => {
      identifiers[name] = {
        fn: keyframes
      };
    });
    state.stylexImport.forEach(name => {
      if (memberExpressions[name] == null) {
        memberExpressions[name] = {};
      }
      memberExpressions[name].include = {
        fn: include_1,
        takesPath: true
      };
      memberExpressions[name].firstThatWorks = {
        fn: firstThatWorks_1
      };
      memberExpressions[name].keyframes = {
        fn: keyframes
      };
    });
    const {
      confident,
      value,
      fns
    } = evaluateStyleXCreateArg(firstArg, state, {
      identifiers,
      memberExpressions
    });
    if (!confident) {
      throw new Error(messages_1.NON_STATIC_VALUE);
    }
    const plainObject = value;
    let [compiledStyles, injectedStylesSansKeyframes] = create_1(plainObject, state.options);
    const injectedStyles = {
      ...injectedKeyframes,
      ...injectedStylesSansKeyframes
    };
    let varName = null;
    if (isVariableDeclarator(path.parentPath)) {
      const idNode = path.parentPath.node.id;
      if (idNode.type === "Identifier") {
        varName = idNode.name;
      }
    }
    if (state.isTest) {
      compiledStyles = {
        ...convertToTestStyles(compiledStyles, varName, state)
      };
    } else if (state.isDev) {
      compiledStyles = {
        ...injectDevClassNames(compiledStyles, varName, state)
      };
    }
    if (varName != null) {
      state.styleMap.set(varName, compiledStyles);
      state.styleVars.set(varName, path.parentPath);
    }
    const resultAst = convertObjectToAST(compiledStyles);
    if (fns != null) {
      resultAst.properties = resultAst.properties.map(prop => {
        if (t__namespace.isObjectProperty(prop)) {
          const key = prop.key.type === "Identifier" && !prop.computed ? prop.key.name : prop.key.type === "StringLiteral" ? prop.key.value : null;
          if (key != null && Object.keys(fns).includes(key)) {
            const [params, inlineStyles] = fns[key];
            if (t__namespace.isExpression(prop.value)) {
              const value = prop.value;
              prop.value = t__namespace.arrowFunctionExpression(params, t__namespace.arrayExpression([value, t__namespace.objectExpression(Object.entries(inlineStyles).map(_ref => {
                let [key, value] = _ref;
                return t__namespace.objectProperty(t__namespace.stringLiteral(key), value);
              }))]));
            }
          }
        }
        return prop;
      });
    }
    path.replaceWith(resultAst);
    if (Object.keys(injectedStyles).length === 0) {
      return;
    }
    if (state.isDev || state.stylexSheetName == null) {
      const statementPath = findNearestStatementAncestor(path);
      const stylexName = getStylexDefaultImport(path, state);
      for (const [_key, {
        ltr,
        priority,
        rtl
      }] of Object.entries(injectedStyles)) {
        statementPath.insertBefore(t__namespace.expressionStatement(t__namespace.callExpression(t__namespace.memberExpression(t__namespace.identifier(stylexName), t__namespace.identifier("inject")), [t__namespace.stringLiteral(ltr), t__namespace.numericLiteral(priority), ...(rtl != null ? [t__namespace.stringLiteral(rtl)] : [])])));
      }
    }
    for (const [key, {
      priority,
      ...rest
    }] of Object.entries(injectedStyles)) {
      state.addStyle([key, rest, priority]);
    }
  }
  state.inStyleXCreate = false;
}
function validateStyleXCreate(path) {
  if (path.parentPath == null || isExpressionStatement(path.parentPath)) {
    throw new Error(messages_1.UNBOUND_STYLEX_CALL_VALUE);
  }
  const nearestStatement = findNearestStatementAncestor(path);
  if (!isProgram(nearestStatement.parentPath) && !isExportNamedDeclaration(nearestStatement.parentPath)) {
    throw new Error(messages_1.ONLY_TOP_LEVEL);
  }
  if (path.node.arguments.length !== 1) {
    throw new Error(messages_1.ILLEGAL_ARGUMENT_LENGTH);
  }
  if (path.node.arguments[0].type !== "ObjectExpression") {
    throw new Error(messages_1.NON_OBJECT_FOR_STYLEX_CALL);
  }
}
function findNearestStatementAncestor(path) {
  if (isStatement(path)) {
    return path;
  }
  if (path.parentPath == null) {
    throw new Error("Unexpected Path found that is not part of the AST.");
  }
  return findNearestStatementAncestor(path.parentPath);
}
function getStylexDefaultImport(path, state) {
  const statementPath = findNearestStatementAncestor(path);
  let stylexName;
  state.stylexImport.forEach(importName => {
    stylexName = importName;
  });
  if (stylexName == null) {
    stylexName = "__stylex__";
    statementPath.insertBefore(t__namespace.importDeclaration([t__namespace.importDefaultSpecifier(t__namespace.identifier(stylexName))], t__namespace.stringLiteral("stylex")));
    state.stylexImport.add(stylexName);
  }
  return stylexName;
}

function transformStyleXCreateVars(callExpressionPath, state) {
  const callExpressionNode = callExpressionPath.node;
  if (callExpressionNode.type !== "CallExpression") {
    return;
  }
  if (callExpressionNode.callee.type === "Identifier" && state.stylexCreateVarsImport.has(callExpressionNode.callee.name) || callExpressionNode.callee.type === "MemberExpression" && callExpressionNode.callee.property.name === "unstable_createVars" && callExpressionNode.callee.object.type === "Identifier" && callExpressionNode.callee.property.type === "Identifier" && state.stylexImport.has(callExpressionNode.callee.object.name)) {
    validateStyleXCreateVars(callExpressionPath);
    const variableDeclaratorPath = callExpressionPath.parentPath;
    if (!isVariableDeclarator(variableDeclaratorPath)) {
      return;
    }
    const variableDeclaratorNode = variableDeclaratorPath.node;
    if (variableDeclaratorNode.id.type !== "Identifier") {
      return;
    }
    const varId = variableDeclaratorNode.id;
    const args = callExpressionPath.get("arguments");
    const firstArg = args[0];
    const identifiers = {};
    const memberExpressions = {};
    const {
      confident,
      value
    } = evaluate(firstArg, state, {
      identifiers,
      memberExpressions
    });
    if (!confident) {
      throw new Error(messages_1.NON_STATIC_VALUE);
    }
    if (typeof value !== "object" || value == null) {
      throw new Error(messages_1.NON_OBJECT_FOR_STYLEX_CALL);
    }
    const fileName = state.fileNameForHashing;
    if (fileName == null) {
      throw new Error("No filename found for generating theme name.");
    }
    const exportName = varId.name;
    const [variablesObj, {
      css
    }] = createVars_1(value, {
      ...state.options,
      themeName: utils_1.genFileBasedIdentifier({
        fileName,
        exportName
      })
    });
    callExpressionPath.replaceWith(convertObjectToAST(variablesObj));
    if (state.isDev || state.stylexSheetName == null) {
      const maybeStatementPath = variableDeclaratorPath.parentPath.parentPath;
      if (maybeStatementPath == null) {
        throw new Error("impossible");
      }
      const statementPath = maybeStatementPath;
      if (!isExportNamedDeclaration(statementPath)) {
        throw new Error("impossible");
      }
      let stylexName;
      state.stylexImport.forEach(importName => {
        stylexName = importName;
      });
      if (stylexName == null) {
        stylexName = "__stylex__";
        statementPath.insertBefore(t__namespace.importDeclaration([t__namespace.importDefaultSpecifier(t__namespace.identifier(stylexName))], t__namespace.stringLiteral("stylex")));
      }
      statementPath.insertBefore(t__namespace.expressionStatement(t__namespace.callExpression(t__namespace.memberExpression(t__namespace.identifier(stylexName), t__namespace.identifier("inject")), [t__namespace.stringLiteral(css), t__namespace.numericLiteral(0)])));
    }
    state.addStyle([variablesObj.__themeName__, {
      ltr: css
    }, 0]);
  }
}
function validateStyleXCreateVars(callExpressionPath) {
  const variableDeclaratorPath = callExpressionPath.parentPath;
  const exportNamedDeclarationPath = variableDeclaratorPath.parentPath?.parentPath;
  if (variableDeclaratorPath == null || variableDeclaratorPath.isExpressionStatement() || !variableDeclaratorPath.isVariableDeclarator() || variableDeclaratorPath.node.id.type !== "Identifier") {
    throw new Error(messages_1.UNBOUND_STYLEX_CALL_VALUE);
  }
  if (exportNamedDeclarationPath == null || !exportNamedDeclarationPath.isExportNamedDeclaration()) {
    throw new Error(messages_1.NON_EXPORT_NAMED_DECLARATION);
  }
  if (callExpressionPath.node.arguments.length !== 1) {
    throw new Error(messages_1.ILLEGAL_ARGUMENT_LENGTH);
  }
}

function transformStyleXOverrideVars(callExpressionPath, state) {
  const callExpressionNode = callExpressionPath.node;
  if (callExpressionNode.type !== "CallExpression") {
    return;
  }
  if (callExpressionNode.callee.type === "Identifier" && state.stylexOverrideVarsImport.has(callExpressionNode.callee.name) || callExpressionNode.callee.type === "MemberExpression" && callExpressionNode.callee.object.type === "Identifier" && callExpressionNode.callee.property.type === "Identifier" && callExpressionNode.callee.property.name === "unstable_overrideVars" && state.stylexImport.has(callExpressionNode.callee.object.name)) {
    validateStyleXOverrideVars(callExpressionPath);
    const variableDeclaratorPath = callExpressionPath.parentPath;
    if (!isVariableDeclarator(variableDeclaratorPath)) {
      return;
    }
    const args = callExpressionPath.get("arguments");
    const firstArg = args[0];
    const secondArg = args[1];
    const {
      confident: confident1,
      value: variables
    } = evaluate(firstArg, state);
    if (!confident1) {
      throw new Error(messages_1.NON_STATIC_VALUE);
    }
    const {
      confident: confident2,
      value: overrides
    } = evaluate(secondArg, state);
    if (!confident2) {
      throw new Error(messages_1.NON_STATIC_VALUE);
    }
    if (typeof overrides !== "object" || overrides == null) {
      throw new Error(messages_1.NON_OBJECT_FOR_STYLEX_CALL);
    }
    if (typeof variables.__themeName__ !== "string" || variables.__themeName__ === "") {
      throw new Error("Can only override variables theme created with stylex.unstable_createVars().");
    }
    const [overridesObj, css] = overrideVars_1(variables, overrides, state.options);
    const styleKey = overridesObj[variables.__themeName__];
    callExpressionPath.replaceWith(convertObjectToAST(overridesObj));
    if (state.isDev || state.stylexSheetName == null) {
      const statementPath = variableDeclaratorPath.parentPath;
      let stylexName;
      state.stylexImport.forEach(importName => {
        stylexName = importName;
      });
      if (stylexName == null) {
        stylexName = "__stylex__";
        statementPath?.insertBefore(t__namespace.importDeclaration([t__namespace.importDefaultSpecifier(t__namespace.identifier(stylexName))], t__namespace.stringLiteral("stylex")));
      }
      statementPath?.insertBefore(t__namespace.expressionStatement(t__namespace.callExpression(t__namespace.memberExpression(t__namespace.identifier(stylexName), t__namespace.identifier("inject")), [t__namespace.stringLiteral(css[styleKey].ltr), t__namespace.numericLiteral(css[styleKey].priority)])));
    }
    state.addStyle([styleKey, {
      ltr: css[styleKey].ltr
    }, css[styleKey].priority]);
  }
}
function validateStyleXOverrideVars(callExpressionPath) {
  const variableDeclaratorPath = callExpressionPath.parentPath;
  if (variableDeclaratorPath == null || variableDeclaratorPath.isExpressionStatement() || !variableDeclaratorPath.isVariableDeclarator() || variableDeclaratorPath.node.id.type !== "Identifier") {
    throw new Error(messages_1.UNBOUND_STYLEX_CALL_VALUE);
  }
  if (callExpressionPath.node.arguments.length !== 2) {
    throw new Error(messages_1.ILLEGAL_ARGUMENT_LENGTH);
  }
}

function transformStyleXKeyframes(path, state) {
  const {
    node
  } = path;
  if (node.init?.type !== "CallExpression") {
    return;
  }
  if (node.id.type !== "Identifier") {
    return;
  }
  const nodeInit = node.init;
  if (nodeInit.callee.type === "Identifier" && state.stylexKeyframesImport.has(nodeInit.callee.name) || nodeInit.callee.type === "MemberExpression" && nodeInit.callee.object.type === "Identifier" && nodeInit.callee.property.name === "keyframes" && nodeInit.callee.property.type === "Identifier" && state.stylexImport.has(nodeInit.callee.object.name)) {
    if (nodeInit.arguments.length !== 1) {
      throw new Error(messages_1.ILLEGAL_ARGUMENT_LENGTH);
    }
    if (nodeInit.arguments[0].type !== "ObjectExpression") {
      throw new Error(messages_1.NON_OBJECT_FOR_STYLEX_CALL);
    }
    const init = path.get("init");
    if (init == null || !isCallExpression(init)) {
      throw new Error(messages_1.NON_STATIC_VALUE);
    }
    const args = init.get("arguments");
    const firstArg = args[0];
    const {
      confident,
      value
    } = firstArg.evaluate();
    if (!confident) {
      throw new Error(messages_1.NON_STATIC_VALUE);
    }
    const plainObject = value;
    assertValidKeyframes(plainObject);
    const [animationName, injectedStyle] = keyframes_1(plainObject, state.options);
    init.replaceWith(t__namespace.stringLiteral(animationName));
    const {
      ltr,
      priority,
      rtl
    } = injectedStyle;
    if ((state.isDev || state.stylexSheetName == null) && isVariableDeclaration(path.parentPath)) {
      const statementPath = path.parentPath;
      let stylexName;
      state.stylexImport.forEach(importName => {
        stylexName = importName;
      });
      if (stylexName == null) {
        stylexName = "__stylex__";
        statementPath.insertBefore(t__namespace.importDeclaration([t__namespace.importDefaultSpecifier(t__namespace.identifier(stylexName))], t__namespace.stringLiteral("stylex")));
      }
      statementPath.insertBefore(t__namespace.expressionStatement(t__namespace.callExpression(t__namespace.memberExpression(t__namespace.identifier(stylexName), t__namespace.identifier("inject")), [t__namespace.stringLiteral(ltr), t__namespace.numericLiteral(priority), ...(rtl != null ? [t__namespace.stringLiteral(rtl)] : [])])));
    }
    state.addStyle([animationName, {
      ltr,
      rtl
    }, priority]);
  }
}
function assertValidKeyframes(obj) {
  if (typeof obj !== "object" || Array.isArray(obj) || obj == null) {
    throw new Error(messages_1.NON_OBJECT_FOR_STYLEX_CALL);
  }
  for (const [_key, value] of Object.entries(obj)) {
    if (typeof value !== "object" || Array.isArray(value)) {
      throw new Error(messages_1.ILLEGAL_NAMESPACE_VALUE);
    }
  }
}

var stylex$1 = {};

var stylexInject = {};

var StyleXSheet$1 = {};

Object.defineProperty(StyleXSheet$1, "__esModule", {
  value: true
});
StyleXSheet$1.styleSheet = StyleXSheet$1.StyleXSheet = void 0;
var _invariant = _interopRequireDefault$1(require$$0$1);
function _interopRequireDefault$1(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const LIGHT_MODE_CLASS_NAME = "__fb-light-mode";
const DARK_MODE_CLASS_NAME = "__fb-dark-mode";
function buildTheme(selector, theme) {
  const lines = [];
  lines.push(`${selector} {`);
  for (const key in theme) {
    const value = theme[key];
    lines.push(`  --${key}: ${value};`);
  }
  lines.push("}");
  return lines.join("\n");
}
function makeStyleTag() {
  const tag = document.createElement("style");
  tag.setAttribute("type", "text/css");
  tag.setAttribute("data-stylex", "true");
  const head = document.head || document.getElementsByTagName("head")[0];
  (0, _invariant.default)(head, "expected head");
  head.appendChild(tag);
  return tag;
}
function doesSupportCSSVariables() {
  return globalThis.CSS != null && globalThis.CSS.supports != null && globalThis.CSS.supports("--fake-var:0");
}
const VARIABLE_MATCH = /var\(--(.*?)\)/g;
class StyleXSheet {
  static LIGHT_MODE_CLASS_NAME = LIGHT_MODE_CLASS_NAME;
  static DARK_MODE_CLASS_NAME = DARK_MODE_CLASS_NAME;
  constructor(opts) {
    this.tag = null;
    this.injected = false;
    this.ruleForPriority = new Map();
    this.rules = [];
    this.rootTheme = opts.rootTheme;
    this.rootDarkTheme = opts.rootDarkTheme;
    this.supportsVariables = opts.supportsVariables ?? doesSupportCSSVariables();
  }
  getVariableMatch() {
    return VARIABLE_MATCH;
  }
  isHeadless() {
    return this.tag == null || globalThis?.document?.body == null;
  }
  getTag() {
    const {
      tag
    } = this;
    (0, _invariant.default)(tag != null, "expected tag");
    return tag;
  }
  getCSS() {
    return this.rules.join("\n");
  }
  getRulePosition(rule) {
    return this.rules.indexOf(rule);
  }
  getRuleCount() {
    return this.rules.length;
  }
  inject() {
    if (this.injected) {
      return;
    }
    this.injected = true;
    if (globalThis.document?.body == null) {
      this.injectTheme();
      return;
    }
    this.tag = makeStyleTag();
    this.injectTheme();
  }
  injectTheme() {
    if (this.rootTheme != null) {
      this.insert(buildTheme(`:root, .${LIGHT_MODE_CLASS_NAME}`, this.rootTheme), 0);
    }
    if (this.rootDarkTheme != null) {
      this.insert(buildTheme(`.${DARK_MODE_CLASS_NAME}:root, .${DARK_MODE_CLASS_NAME}`, this.rootDarkTheme), 0);
    }
  }
  __injectCustomThemeForTesting(selector, theme) {
    if (theme != null) {
      this.insert(buildTheme(selector, theme), 0);
    }
  }
  delete(rule) {
    const index = this.rules.indexOf(rule);
    (0, _invariant.default)(index >= 0, "Couldn't find the index for rule %s", rule);
    this.rules.splice(index, 1);
    if (this.isHeadless()) {
      return;
    }
    const tag = this.getTag();
    const sheet = tag.sheet;
    (0, _invariant.default)(sheet, "expected sheet");
    sheet.deleteRule(index);
  }
  normalizeRule(rule) {
    const {
      rootTheme
    } = this;
    if (this.supportsVariables || rootTheme == null) {
      return rule;
    }
    return rule.replace(VARIABLE_MATCH, (_match, name) => {
      return rootTheme[name];
    });
  }
  getInsertPositionForPriority(priority) {
    const priorityRule = this.ruleForPriority.get(priority);
    if (priorityRule != null) {
      return this.rules.indexOf(priorityRule) + 1;
    }
    const priorities = Array.from(this.ruleForPriority.keys()).sort((a, b) => b - a).filter(num => num > priority ? 1 : 0);
    if (priorities.length === 0) {
      return this.getRuleCount();
    }
    const lastPriority = priorities.pop();
    return this.rules.indexOf(this.ruleForPriority.get(lastPriority));
  }
  insert(rawLTRRule, priority, rawRTLRule) {
    if (this.injected === false) {
      this.inject();
    }
    if (rawRTLRule != null) {
      this.insert(addAncestorSelector$1(rawLTRRule, "html:not([dir='rtl'])"), priority);
      this.insert(addAncestorSelector$1(rawRTLRule, "html[dir='rtl']"), priority);
      return;
    }
    const rawRule = rawLTRRule;
    if (this.rules.includes(rawRule)) {
      return;
    }
    const rule = this.normalizeRule(rawRule);
    const insertPos = this.getInsertPositionForPriority(priority);
    this.rules.splice(insertPos, 0, rule);
    this.ruleForPriority.set(priority, rule);
    if (this.isHeadless()) {
      return;
    }
    const tag = this.getTag();
    const sheet = tag.sheet;
    if (sheet != null) {
      try {
        sheet.insertRule(rule, insertPos);
      } catch {}
    }
  }
}
StyleXSheet$1.StyleXSheet = StyleXSheet;
function addAncestorSelector$1(selector, ancestorSelector) {
  if (!selector.startsWith("@")) {
    return `${ancestorSelector} ${selector}`;
  }
  const firstBracketIndex = selector.indexOf("{");
  const mediaQueryPart = selector.slice(0, firstBracketIndex + 1);
  const rest = selector.slice(firstBracketIndex + 1);
  return `${mediaQueryPart}${ancestorSelector} ${rest}`;
}
const styleSheet = new StyleXSheet({
  supportsVariables: true,
  rootTheme: {},
  rootDarkTheme: {}
});
StyleXSheet$1.styleSheet = styleSheet;

Object.defineProperty(stylexInject, "__esModule", {
  value: true
});
stylexInject.default = inject$1;
var _StyleXSheet = StyleXSheet$1;
function inject$1(ltrRule, priority) {
  let rtlRule = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  _StyleXSheet.styleSheet.insert(ltrRule, priority, rtlRule);
}

Object.defineProperty(stylex$1, "__esModule", {
  value: true
});
stylex$1.keyframes = stylex$1.inject = stylex$1.include = stylex$1.firstThatWorks = default_1 = stylex$1.default = stylex$1.create = stylex$1.UNSUPPORTED_PROPERTY = void 0;
stylex$1.spread = spread;
stylex$1.unstable_overrideVars = stylex$1.unstable_createVars = stylex$1.types = stylex$1.stylex = void 0;
var _stylexInject = _interopRequireDefault(stylexInject);
var _styleq = require$$1;
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function spread(styles, _options) {
  const [className, style] = (0, _styleq.styleq)(styles);
  return {
    className,
    style
  };
}
function stylexCreate(_styles) {
  throw new Error("stylex.create should never be called. It should be compiled away.");
}
function stylexCreateVars(_styles) {
  throw new Error("stylex.createVars should never be called. It should be compiled away.");
}
function stylexOverrideVars(_styles) {
  throw new Error("stylex.overrideVars should never be called. It should be compiled away.");
}
function stylexIncludes(_styles) {
  throw new Error("stylex.extends should never be called. It should be compiled away.");
}
const create = stylexCreate;
stylex$1.create = create;
const unstable_createVars = stylexCreateVars;
stylex$1.unstable_createVars = unstable_createVars;
const unstable_overrideVars = stylexOverrideVars;
stylex$1.unstable_overrideVars = unstable_overrideVars;
const include = stylexIncludes;
stylex$1.include = include;
const types = {
  angle: _v => {
    throw new Error(errorForType("angle"));
  },
  color: _v => {
    throw new Error(errorForType("color"));
  },
  url: _v => {
    throw new Error(errorForType("url"));
  },
  image: _v => {
    throw new Error(errorForType("image"));
  },
  integer: _v => {
    throw new Error(errorForType("integer"));
  },
  lengthPercentage: _v => {
    throw new Error(errorForType("lengthPercentage"));
  },
  length: _v => {
    throw new Error(errorForType("length"));
  },
  percentage: _v => {
    throw new Error(errorForType("percentage"));
  },
  number: _v => {
    throw new Error(errorForType("number"));
  },
  resolution: _v => {
    throw new Error(errorForType("resolution"));
  },
  time: _v => {
    throw new Error(errorForType("time"));
  },
  transformFunction: _v => {
    throw new Error(errorForType("transformFunction"));
  },
  transformList: _v => {
    throw new Error(errorForType("transformList"));
  }
};
stylex$1.types = types;
const errorForType = type => `stylex.types.${type} should be compiled away by @stylexjs/babel-plugin`;
const keyframes = _keyframes => {
  throw new Error("stylex.keyframes should never be called");
};
stylex$1.keyframes = keyframes;
const firstThatWorks = function () {
  throw new Error("stylex.firstThatWorks should never be called.");
};
stylex$1.firstThatWorks = firstThatWorks;
const inject = _stylexInject.default;
stylex$1.inject = inject;
const UNSUPPORTED_PROPERTY = _props => {
  throw new Error("stylex.UNSUPPORTED_PROPERTY should never be called. It should be compiled away.");
};
stylex$1.UNSUPPORTED_PROPERTY = UNSUPPORTED_PROPERTY;
function _stylex() {
  for (var _len = arguments.length, styles = new Array(_len), _key = 0; _key < _len; _key++) {
    styles[_key] = arguments[_key];
  }
  const [className] = (0, _styleq.styleq)(styles);
  return className;
}
_stylex.spread = spread;
_stylex.create = create;
_stylex.unstable_createVars = unstable_createVars;
_stylex.unstable_overrideVars = unstable_overrideVars;
_stylex.include = include;
_stylex.keyframes = keyframes;
_stylex.firstThatWorks = firstThatWorks;
_stylex.inject = inject;
_stylex.UNSUPPORTED_PROPERTY = UNSUPPORTED_PROPERTY;
_stylex.types = types;
const stylex = _stylex;
stylex$1.stylex = stylex;
var _default = _stylex;
var default_1 = stylex$1.default = _default;

function skipStylexMergeChildren(path, state) {
  const {
    node
  } = path;
  if (node == null || node.callee.type !== "Identifier" || !state.stylexImport.has(node.callee.name)) {
    return;
  }
  path.skip();
}
function transformStyleXMerge(path, state) {
  const {
    node
  } = path;
  if (node == null || node.callee.type !== "Identifier" || !state.stylexImport.has(node.callee.name)) {
    return;
  }
  let bailOut = false;
  let conditional = 0;
  const resolvedArgs = [];
  for (const arg of node.arguments) {
    switch (arg.type) {
      case "MemberExpression":
        {
          const resolved = parseNullableStyle(arg, state);
          if (resolved === "other") {
            bailOut = true;
          } else {
            resolvedArgs.push(resolved);
          }
          break;
        }
      case "ConditionalExpression":
        {
          const {
            test,
            consequent,
            alternate
          } = arg;
          const primary = parseNullableStyle(consequent, state);
          const fallback = parseNullableStyle(alternate, state);
          if (primary === "other" || fallback === "other") {
            bailOut = true;
          } else {
            resolvedArgs.push([test, primary, fallback]);
            conditional++;
          }
          break;
        }
      case "LogicalExpression":
        {
          if (arg.operator !== "&&") {
            bailOut = true;
            break;
          }
          const {
            left,
            right
          } = arg;
          const leftResolved = parseNullableStyle(left, state);
          const rightResolved = parseNullableStyle(right, state);
          if (leftResolved !== "other" || rightResolved === "other") {
            bailOut = true;
          } else {
            resolvedArgs.push([left, rightResolved, null]);
            conditional++;
          }
          break;
        }
      default:
        bailOut = true;
        break;
    }
    if (conditional > 4) {
      bailOut = true;
    }
    if (bailOut) {
      break;
    }
  }
  if (!state.options.genConditionalClasses && conditional) {
    bailOut = true;
  }
  if (bailOut) {
    path.traverse({
      MemberExpression(path) {
        const object = path.get("object").node;
        const property = path.get("property").node;
        const computed = path.node.computed;
        let objName = null;
        let propName = null;
        if (object.type === "Identifier" && state.styleMap.has(object.name)) {
          objName = object.name;
          if (property.type === "Identifier" && !computed) {
            propName = property.name;
          }
          if ((property.type === "StringLiteral" || property.type === "NumericLiteral") && computed) {
            propName = property.value;
          }
        }
        if (objName != null) {
          state.styleVarsToKeep.add([objName, propName != null ? String(propName) : null]);
        }
      }
    });
  } else {
    path.skip();
    const stringExpression = makeStringExpression(resolvedArgs);
    path.replaceWith(stringExpression);
  }
}
function parseNullableStyle(node, state) {
  if (t__namespace.isNullLiteral(node) || t__namespace.isIdentifier(node) && node.name === "undefined") {
    return null;
  }
  if (t__namespace.isMemberExpression(node)) {
    const {
      object,
      property,
      computed: computed
    } = node;
    let objName = null;
    let propName = null;
    if (object.type === "Identifier" && state.styleMap.has(object.name) && property.type === "Identifier" && !computed) {
      objName = object.name;
      propName = property.name;
    }
    if (object.type === "Identifier" && state.styleMap.has(object.name) && (property.type === "StringLiteral" || property.type === "NumericLiteral") && computed) {
      objName = object.name;
      propName = property.value;
    }
    if (objName != null && propName != null) {
      const style = state.styleMap.get(objName);
      if (style != null && style[String(propName)] != null) {
        return style[String(propName)];
      }
    }
  }
  return "other";
}
function makeStringExpression(values) {
  const conditions = values.filter(v => Array.isArray(v)).map(v => v[0]);
  if (conditions.length === 0) {
    return t__namespace.stringLiteral(default_1(...values));
  }
  const conditionPermutations = genConditionPermutations(conditions.length);
  const objEntries = conditionPermutations.map(permutation => {
    let i = 0;
    const args = values.map(v => {
      if (Array.isArray(v)) {
        const [_test, primary, fallback] = v;
        return permutation[i++] ? primary : fallback;
      } else {
        return v;
      }
    });
    const key = permutation.reduce((soFar, bool) => soFar << 1 | (bool ? 1 : 0), 0);
    return t__namespace.objectProperty(t__namespace.numericLiteral(key), t__namespace.stringLiteral(default_1(...args)));
  });
  const objExpressions = t__namespace.objectExpression(objEntries);
  const conditionsToKey = genBitwiseOrOfConditions(conditions);
  return t__namespace.memberExpression(objExpressions, conditionsToKey, true);
}
function genConditionPermutations(count) {
  const result = [];
  for (let i = 0; i < 2 ** count; i++) {
    const combination = [];
    for (let j = 0; j < count; j++) {
      combination.push(Boolean(i & 1 << j));
    }
    result.push(combination);
  }
  return result;
}
function genBitwiseOrOfConditions(conditions) {
  const binaryExpressions = conditions.map((condition, i) => {
    const shift = conditions.length - i - 1;
    return t__namespace.binaryExpression("<<", t__namespace.unaryExpression("!", t__namespace.unaryExpression("!", condition)), t__namespace.numericLiteral(shift));
  });
  return binaryExpressions.reduce((acc, expr) => {
    return t__namespace.binaryExpression("|", acc, expr);
  });
}

const NAME = "stylex";
function styleXTransform() {
  let state;
  return {
    name: NAME,
    visitor: {
      Program: {
        enter: (path, s) => {
          state = new StateManager(s);
          for (const block of path.get("body")) {
            if (isImportDeclaration(block)) {
              readImportDeclarations(block, state);
            }
            if (isVariableDeclaration(block)) {
              for (const decl of block.get("declarations")) {
                readRequires(decl, state);
              }
            }
          }
          path.traverse({
            CallExpression(path) {
              if (isVariableDeclarator(path.parentPath)) {
                transformStyleXKeyframes(path.parentPath, state);
              }
              transformStyleXCreateVars(path, state);
              transformStyleXOverrideVars(path, state);
              transformStyleXCreate(path, state);
            }
          });
        },
        exit: path => {
          path.traverse({
            CallExpression(path) {
              transformStyleXMerge(path, state);
            }
          });
          const varsToKeep = new Set([...state.styleVarsToKeep.values()].map(_ref => {
            let [varName, _namespaceName] = _ref;
            return varName;
          }));
          state.styleVars.forEach((path, varName) => {
            if (!varsToKeep.has(varName) && !isExported(path)) {
              path.remove();
            }
          });
        }
      },
      CallExpression(path) {
        skipStylexMergeChildren(path, state);
      },
      Identifier(path) {
        if (isReferencedIdentifier(path)) {
          const {
            name
          } = path.node;
          if (state.styleMap.has(name)) {
            const parentPath = path.parentPath;
            if (isMemberExpression(parentPath)) {
              const {
                property,
                computed
              } = parentPath.node;
              if (property.type === "Identifier" && !computed) {
                state.markComposedNamespace([name, property.name]);
              }
              if (property.type === "StringLiteral" && computed) {
                state.markComposedNamespace([name, property.value]);
              }
              state.markComposedNamespace([name, null]);
            } else {
              state.markComposedNamespace([name, null]);
            }
          }
        }
      }
    }
  };
}
function isExported(path) {
  if (path == null || isProgram(path)) {
    return false;
  }
  if (isExportNamedDeclaration(path) || isExportDefaultDeclaration(path)) {
    return true;
  }
  return isExported(path.parentPath);
}
function processStylexRules(rules) {
  if (rules.length === 0) {
    return "";
  }
  const sortedRules = rules.sort((_ref2, _ref3) => {
    let [_1, {
      ltr: rule1
    }, firstPriority] = _ref2;
    let [_2, {
      ltr: rule2
    }, secondPriority] = _ref3;
    const priorityComparison = firstPriority - secondPriority;
    if (priorityComparison !== 0) return priorityComparison;
    if (rule1.startsWith("@") && !rule2.startsWith("@")) {
      const query1 = rule1.slice(0, rule1.indexOf("{"));
      const query2 = rule2.slice(0, rule2.indexOf("{"));
      if (query1 !== query2) {
        return query1.localeCompare(query2);
      }
    }
    const property1 = rule1.slice(rule1.lastIndexOf("{"));
    const property2 = rule2.slice(rule2.lastIndexOf("{"));
    return property1.localeCompare(property2);
  });
  const collectedCSS = Array.from(new Map(sortedRules.map(_ref4 => {
    let [a, b, _c] = _ref4;
    return [a, b];
  })).values()).flatMap(_ref5 => {
    let {
      ltr,
      rtl
    } = _ref5;
    return rtl != null ? [addAncestorSelector(ltr, "html:not([dir='rtl'])"), addAncestorSelector(rtl, "html[dir='rtl']")] : [ltr];
  }).join("\n");
  return collectedCSS;
}
styleXTransform.processStylexRules = processStylexRules;
function addAncestorSelector(selector, ancestorSelector) {
  if (!selector.startsWith("@")) {
    return `${ancestorSelector} ${selector}`;
  }
  const firstBracketIndex = selector.indexOf("{");
  const mediaQueryPart = selector.slice(0, firstBracketIndex + 1);
  const rest = selector.slice(firstBracketIndex + 1);
  return `${mediaQueryPart}${ancestorSelector} ${rest}`;
}

module.exports = styleXTransform;
